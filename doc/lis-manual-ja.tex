\documentclass[a4paper]{jarticle}
\usepackage{ascmac,graphicx,epic,eepic,itembbox}
\setlength{\topmargin}{-0.8cm}
\setlength{\oddsidemargin}{0.0cm}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{22.4cm}
 \newcommand{\R}{\mbox{\boldmath $R$}}
 \newcommand{\vx}{\mbox{\boldmath $x$}}
 \newcommand{\vy}{\mbox{\boldmath $y$}}
 \newcommand{\va}{\mbox{\boldmath $a$}}
 \newcommand{\vr}{\mbox{\boldmath $r$}}
 \newcommand{\vf}{\mbox{\boldmath $f$}}
 \newcommand{\vb}{\mbox{\boldmath $b$}}
 \newcommand{\vc}{\mbox{\boldmath $c$}}
 \newcommand{\vu}{\mbox{\boldmath $u$}}
 \newcommand{\vz}{\mbox{\boldmath $z$}}
 \newcommand{\ve}{\mbox{\boldmath $e$}}
 \newcommand{\vv}{\mbox{\boldmath $v$}}
 \newcommand{\vzero}{\mbox{\boldmath $0$}}
 \newcommand{\vd}{\mbox{\boldmath $d$}}
 \newcommand{\vxi}{\mbox{\boldmath $\xi$}}
 \newcommand{\vZ}{\mbox{\boldmath $Z$}^{n \times n}}
 \newcommand{\vepsilon}{\mbox{\boldmath $\varepsilon$}}
\newcommand{\namelistlabel}[1]{\mbox{#1}\hfill}
\newenvironment{namelist}[1]{%
 \begin{list}{}
  {\let\makelabel\namelistlabel
  \settowidth{\labelwidth}{#1}
  \setlength{\leftmargin}{1.1\labelwidth}}
}{%
\end{list}}
\makeatletter
\@addtoreset{equation}{section}
\def\theequation{\thesection.\arabic{equation}}
\makeatother
\title{Lis ユーザマニュアル Revision 1.2.71}
\author{}
\begin{document}
\vspace*{4cm}
\begin{flushleft}
{\Large Lis ユーザマニュアル}\\
バージョン 1.2.71
\end{flushleft}

\vspace*{2cm}
\begin{figure}[h]
\includegraphics[scale=0.7]{irises_korin.eps}
\end{figure}
\vspace*{2cm}

\begin{flushleft}
{\large The Scalable Software Infrastructure
Project\\
{\tt http://www.ssisc.org/}}\\
\end{flushleft}
\vspace*{5mm}
\begin{flushleft}
2012年6月29日
\end{flushleft}
\thispagestyle{empty}

\newpage
\begin{flushleft}
{\small
Copyright (C) 2002-2012 The Scalable Software Infrastructure Project,
supported by ``Development of Software Infrastructure for Large Scale
Scientific Simulation'' Team, CREST, JST

Akira Nishida, Research Institute for Information Technology, 
Kyushu University, 6-10-1, Hakozaki, Higashi-ku, Fukuoka 812-8581 Japan

All rights reserved.

\vspace*{5mm}
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
 met:

1. Redistributions of source code must retain the above copyright
 notice, 
   this list of conditions and the following disclaimer. 

2. Redistributions in binary form must reproduce the above copyright
 notice,
   this list of conditions and the following disclaimer in the
 documentation
   and/or other materials provided with the distribution. 

3. Neither the name of the University nor the names of its contributors
 may 
   be used to endorse or promote products derived from this software
 without
   specific prior written permission. 

\vspace*{5mm}
THIS SOFTWARE IS PROVIDED BY THE SCALABLE SOFTWARE INFRASTRUCTURE
 PROJECT 
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE SCALABLE SOFTWARE
 INFRASTRUCTURE
PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE
POSSIBILITY OF SUCH DAMAGE.

\vfill
表紙: 尾形光琳, 燕子花図.
}
\end{flushleft}
\thispagestyle{empty}

\newpage
\pagenumbering{roman}
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setcounter{section}{-1}
\newpage
 \pagenumbering{arabic}
\section{Version 1.1からの追加・変更点}
\begin{enumerate}
\item 固有値解法を追加
\item ユーザインタフェースの仕様を一部変更
\begin{enumerate}
\item {\tt lis\_output\_residual\_history()}, {\tt lis\_get\_residual\_history()}をそれぞれ\\
{\tt lis\_solver\_output\_rhistory()}, {\tt lis\_solver\_get\_rhistory()}に変更
\item Fortranサブルーチン{\tt lis\_vector\_set\_value()},
      {\tt lis\_vector\_get\_value()}の\\オリジンを1に変更
\item Fortranサブルーチン{\tt lis\_vector\_set\_size()}のオリジンを1に変更
\item 演算精度に関するオプションの名称を{\tt -precision}から{\tt -f}に変更
\end{enumerate}
\end{enumerate}

\newpage
\section{はじめに}
Lis (a Library of Iterative Solvers for linear systems)は, 大規模実疎行列を
係数とする線型方程式系 
\[
Ax = b
\]
及び標準固有値問題
\[
Ax = \lambda x
\]
を解くための反復法ライブラリである. CとFortranで記述されており, 
逐次版, OpenMPを使用する共有メモリ並列版, MPIを使用する分散メモリ並列版がある. 
対応する線型方程式系解法, 固有値解法の一覧を表\ref{tab:solvers}-\ref{tab:esolvers}, 
前処理を表\ref{tab:precon}に示す. 
また行列格納形式の一覧を表\ref{tab:storage}に示す. 

\begin{table}[htb]
\begin{minipage}[t]{0.30\textwidth}
\caption{線型方程式系解法} 
\vspace*{1mm}
\label{tab:solvers}
\hbox to\hsize{\hfil
\begin{tabular}{l|l}\hline\hline
CG                      & CR \\ 
BiCG                    & BiCR\cite{sogabe01} \\
CGS                     & CRS\cite{abe02} \\
BiCGSTAB                & BiCRSTAB\cite{abe02} \\
GPBiCG                  & GPBiCR\cite{abe02} \\
BiCGSafe\cite{fujino01} & BiCRSafe\cite{fujino02} \\
BiCGSTAB(l)             & TFQMR \\
Jacobi                  & Orthomin(m) \\
Gauss-Seidel            & GMRES(m) \\
SOR                     & FGMRES(m)\cite{fgmres} \\
IDR(s)\cite{idrs}       & MINRES\cite{greenbaum} \\
\hline         
\end{tabular}
\hfil}
\end{minipage}
\hspace*{12mm}
\begin{minipage}[t]{0.30\textwidth}
\caption{固有値解法} 
\vspace*{1mm}
\label{tab:esolvers}
\hbox to\hsize{\hfil
\begin{tabular}{l}\hline\hline
Power Iteration \\
Inverse Iteration \\
Approximate Inverse Iteration \\
Rayleigh Quotient Iteration \\
Subspace Iteration \\
Lanczos Iteration \\
Conjugate Gradient\cite{knyazev,nishida1} \\
Conjugate Residual\cite{suetomi} \\
\hline         
\end{tabular}
\hfil}
\end{minipage}
\newline
\begin{minipage}[t]{0.30\textwidth}
\caption{前処理} 
\vspace*{1mm}
\label{tab:precon}
\hbox to\hsize{\hfil
\begin{tabular}{l}\hline\hline
Jacobi \\
SSOR   \\
ILU(k) \\
ILUT\cite{ilut,ITSOL} \\
Crout ILU\cite{iluc,ITSOL} \\
I+S\cite{kohno01} \\
SA-AMG\cite{fujii01}  \\
Hybrid\cite{abe01} \\
SAINV\cite{bridson01}  \\
Additive Schwarz \\
ユーザ定義 \\
\hline         
\end{tabular}
\hfil}
\end{minipage}
\hspace*{-4mm}
\begin{minipage}[t]{0.30\textwidth}
\caption{格納形式} 
\vspace*{1mm}
\label{tab:storage}
\hbox to\hsize{\hfil
\begin{tabular}{ll}\hline\hline
Compressed Row Storage & (CRS) \\
Compressed Column Storage & (CCS) \\
Modified Compressed Sparse Row & (MSR) \\
Diagonal &(DIA) \\
Ellpack-Itpack generalized diagonal &(ELL) \\
Jagged Diagonal &(JDS) \\
Block Sparse Row & (BSR) \\
Block Sparse Column &(BSC) \\
Variable Block Row &(VBR) \\
Dense &	(DNS) \\
Coordinate & (COO) \\
\hline         
\end{tabular}
\hfil}
\end{minipage}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{インストール}
本節では, Lisのインストール, テストの手順について述べる. 
なおここではLinuxクラスタ環境を想定している. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{必要なシステム}
LisのインストールにはCコンパイラが必要である. 
また, Fortranインタフェースを使用する場合はFortranコンパイラ, 
AMG前処理ルーチンを使用する場合はFortran 90コンパイラも必要
となる. 並列計算環境では, OpenMPまたはMPI-1を使用する. 
表\ref{platforms}に主な動作確認環境を示す
 (表\ref{targetoption}も参照のこと). 

\begin{table}[htbp]
\caption{主な動作確認環境}
\label{platforms}
\begin{center}
{\small
 \begin{tabular}{l|l}
\hline
\multicolumn{1}{c|}{Cコンパイラ (必須) } & \multicolumn{1}{c}{OS} \\
\hline
Intel C/C++ Compiler 7.0, 8.0, 9.1, 10.1, 11.1,  & Linux \\
Intel C++ Composer XE                            & Windows  \\
\hline
IBM XL C/C++ V7.0, 9.0                     & AIX   \\
                                           & Linux \\
\hline
Sun WorkShop 6, Sun ONE Studio 7,          & Solaris \\
Sun Studio 11, 12                          &         \\
\hline
PGI C++ 6.0, 7.1, 10.5                     & Linux \\
\hline
gcc 3.3, 4.3                               & Linux \\
                                           & Mac OS X \\
                                           & Windows \\
\hline
Microsoft Visual C++ 2008, 2010            & Windows \\
\hline
\hline
\multicolumn{1}{c|}{Fortranコンパイラ (オプション) } & \multicolumn{1}{c}{OS} \\
\hline
Intel Fortran Compiler 8.1, 9.1, 10.1, 11.1, & Linux \\
Intel Fortran Composer XE                    & Windows  \\
\hline
IBM XL Fortran V9.1, 11.1                  & AIX     \\
                                           & Linux   \\
\hline
Sun WorkShop 6, Sun ONE Studio 7,          & Solaris \\
Sun Studio 11, 12                          &         \\
\hline
PGI Fortran 6.0, 7.1, 10.5                 & Linux \\
\hline
g77 3.3                                    & Linux \\
gfortran 4.3, 4.4                          & Mac OS X \\
g95 0.91                                   & Windows \\
\hline
\end{tabular}
}
\end{center}
\end{table} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{ファイルの展開}
 次のコマンドを入力して, ファイルを展開する. \verb|($VERSION)|はバージョンを示す. \\
 \verb&      >gunzip -c lis-($VERSION).tar.gz | tar xvf - &\\
 これにより, ディレクトリ{\tt lis-(\$VERSION)}下に
図\ref{listargz}に示すサブディレクトリが作成される. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[htbp]
\begin{center}
\small
\begin{verbatim}
lis-($VERSION)
├config
｜  設定ファイル
├include
｜  ヘッダファイル
├src
｜  ソースファイル
├test
｜  テストプログラム
└win32
    Windows環境用のファイル
\end{verbatim}
\end{center}
\caption{{\tt lis-(\$VERSION).tar.gz}のファイル構成}
\label{listargz}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{UNIX及び互換システムの場合}
 \subsubsection{configureスクリプトの実行}
 次のコマンドを入力してスクリプトを実行し, makefileを生成する. 
 \begin{itemize}
\item デフォルトの設定を利用する場合 : \verb&      >./configure&
\item インストール先を指定する場合 :   \verb&      >./configure --prefix=<install-dir>&
\end{itemize}
指定できるオプションを表\ref{configoption}に示す. 
表\ref{targetoption}に\verb+TARGET+で指定できる主な計算機環境を示す. 
\begin{table}[htbp]
\caption{主なconfigureオプション (一覧は {\tt ./configure --help}を参照) }
\label{configoption}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\verb+--enable-omp+      & OpenMPを利用\\ \hline
\verb+--enable-mpi+      & MPIを利用\\ \hline
\verb+--enable-fortran+  & Fortran APIを利用\\ \hline
\verb+--enable-saamg+    & SA-AMG前処理を利用\\ \hline
\verb+--enable-quad+     & 4倍精度演算を利用\\ \hline
\verb+--enable-gprof+    & gprofを利用\\ \hline
\verb+--enable-shared+   & 共有ライブラリを作成\\ \hline
\verb+--prefix=<install-dir>+    & インストール先を指定\\ \hline
\verb+TARGET=<target>+    & 計算機環境を指定\\ \hline
\verb+CC=<c_compiler>+    & Cコンパイラを指定\\ \hline
\verb+CFLAGS=<c_flags>+    & Cコンパイラオプションを指定\\ \hline
\verb+FC=<fortran_compiler>+    & Fortranコンパイラを指定\\ \hline
\verb+FCFLAGS=<fc_flags>+    & Fortranコンパイラオプションを指定\\ \hline
\verb+LDFLAGS=<ld_flags>+    & リンクオプションを指定\\ \hline
\end{tabular}
\end{center}
\end{table}
\begin{table}[htbp]
\caption{TARGETの例 (一覧は{\tt configure}を参照) }
\label{targetoption}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\verb+<target>+       & 実行されるconfigureスクリプト \\ \hline
\verb+cray_xt3+       & \verb+./configure CC=cc FC=ftn CFLAGS="-O3 -B -fastsse -tp k8-64"+ \\
                      & \verb+  FCFLAGS="-O3 -fastsse -tp k8-64 -Mpreprocess" FCLDFLAGS="-Mnomain"+\\
                      & \verb+  ac_cv_sizeof_void_p=8 cross_compiling=yes --enable-mpi+\\
                      & \verb+  ax_f77_mangling="lower case, no underscore, extra underscore"+ \\ \hline
\verb+fujitsu_pq+     & \verb|./configure CC=fcc FC=frt ac_cv_sizeof_void_p=8| \\
                      & \verb+  CFLAGS="-O3 -Kfast,ocl,preex" FFLAGS="-O3 -Kfast,ocl,preex -Cpp"+ \\
                      & \verb+  FCFLAGS="-O3 -Kfast,ocl,preex -Cpp -Am"+\\
                      & \verb+  ax_f77_mangling="lower case, underscore, no extra underscore"+ \\ \hline
\verb+hitachi+        & \verb|./configure CC=cc FC=f90 FCLDFLAGS="-lf90s" ac_cv_sizeof_void_p=8| \\
                      & \verb+  CFLAGS="-Os -noparallel" FCFLAGS="-Oss -noparallel"+ \\
                      & \verb+  ax_f77_mangling="lower case, underscore, no extra underscore" + \\ \hline
\verb+ibm_bgl+        & \verb+./configure CC=blrts_xlc FC=blrts_xlf90+ \\
                      & \verb+  CFLAGS="-O3 -qarch=440d -qtune=440 -qstrict+ \\
                      & \verb+  -I/bgl/BlueLight/ppcfloor/bglsys/include"+ \\
                      & \verb+  FFFLAGS="-O3 -qarch=440d -qtune=440 -qsuffix=cpp=F -qfixed=72 -w+ \\
                      & \verb+  -I/bgl/BlueLight/ppcfloor/bglsys/include"+ \\
                      & \verb+  FCFLAGS="-O3 -qarch=440d -qtune=440 -qsuffix=cpp=F90 -w+ \\
                      & \verb+  -I/bgl/BlueLight/ppcfloor/bglsys/include"+ \\
                      & \verb+  ac_cv_sizeof_void_p=4 cross_compiling=yes --enable-mpi+\\
                      & \verb+  ax_f77_mangling="lower case, no underscore, no extra underscore"+ \\ \hline
\verb+nec_es+         & \verb|./configure CC=esmpic++ FC=esmpif90 AR=esar RANLIB=true | \\
                      & \verb+  ac_cv_sizeof_void_p=8 ax_vector_machine=yes cross_compiling=yes+ \\
                      & \verb+  --enable-mpi --enable-omp+ \\
                      & \verb+  ax_f77_mangling="lower case, no underscore, extra underscore"+ \\ \hline
\verb+nec_sx9_cross+  & \verb|./configure CC=sxmpic++ FC=sxmpif90 AR=sxar RANLIB=true | \\
                      & \verb+  ac_cv_sizeof_void_p=8 ax_vector_machine=yes cross_compiling=yes+ \\ 
                      & \verb+  ax_f77_mangling="lower case, no underscore, extra underscore"+ \\ \hline
\end{tabular}
\end{center}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsubsection{実行ファイルの生成}
 {\tt lis-(\$VERSION)}ディレクトリにおいて次のコマンドを入力し, 実行ファイルを生成する.\\
 \verb+      >make +\\
 実行ファイルが正常に生成されたかどうかを確認するには, 
 {\tt lis-(\$VERSION)}ディレクトリにおいて次のコマンドを入力し, {\tt lis-(\$VERSION)/test}ディレクトリに生成された実行ファイルを用いてテストを行う. \\
 \verb+      >make check+\\
 このテストでは, Matrix Market形式のファイル{\tt test/testmat.mtx}
 から行列, ベクトルデータを読み込み, 線型方程式系$Ax=b$の解を
 {\tt test/sol.txt}に, また収束履歴を{\tt test/res.txt}に書き出す. 
 解の要素がすべて$1$ならば正常である. SGI Altix 3700上での実行結果を以下に示す. 
\begin{itembox}[l]{デフォルト}
 \begin{minipage}{10cm}
 \begin{verbatim}
matrix size = 100 x 100 (460 nonzero entries)
initial vector x = 0
precision : double
solver    : BiCG 2
precon    : none
storage   : CRS
lis_solve : normal end

BiCG: number of iterations     = 15 (double = 15, quad = 0)
BiCG: elapsed time             = 5.178690e-03 sec.
BiCG:   preconditioner         = 1.277685e-03 sec.
BiCG:     matrix creation      = 1.254797e-03 sec.
BiCG:   linear solver          = 3.901005e-03 sec.
BiCG: relative residual 2-norm = 6.327297e-15
\end{verbatim}
\end{minipage}
\end{itembox}
\begin{itembox}[l]{{\tt --enable-omp}}
 \begin{minipage}{10cm}
 \begin{verbatim}
max number of threads = 32
number of threads = 2
matrix size = 100 x 100 (460 nonzero entries)
initial vector x = 0
precision : double
solver    : BiCG 2
precon    : none
storage   : CRS
lis_solve : normal end

BiCG: number of iterations     = 15 (double = 15, quad = 0)
BiCG: elapsed time             = 8.960009e-03 sec.
BiCG:   preconditioner         = 2.297878e-03 sec.
BiCG:     matrix creation      = 2.072096e-03 sec.
BiCG:   linear solver          = 6.662130e-03 sec.
BiCG: relative residual 2-norm = 6.221213e-15
\end{verbatim}
\end{minipage}
\end{itembox}
\begin{itembox}[l]{\tt --enable-mpi}
 \begin{minipage}{10cm}
 \begin{verbatim}
number of processes = 2
matrix size = 100 x 100 (460 nonzero entries)
initial vector x = 0
precision : double
solver    : BiCG 2
precon    : none
storage   : CRS
lis_solve : normal end

BiCG: number of iterations     = 15 (double = 15, quad = 0)
BiCG: elapsed time             = 2.911400e-03 sec.
BiCG:   preconditioner         = 1.560780e-04 sec.
BiCG:     matrix creation      = 1.459997e-04 sec.
BiCG:   linear solver          = 2.755322e-03 sec.
BiCG: relative residual 2-norm = 6.221213e-15
\end{verbatim}
\end{minipage}
\end{itembox}
\subsubsection{インストール}
 {\tt lis-(\$VERSION)}ディレクトリにおいて次のコマンドを入力し, インストール先のディレクトリにファイルをコピーする.\\
 \verb+      >make install+\\ 
\begin{verbatim}
$(INSTALLDIR)
├include
｜  └lis_config.h lis.h lisf.h
└lib
    └liblis.a
\end{verbatim}
{\tt lis\_config.h}はライブラリを生成する際に, また{\tt lis.h}はC, {\tt lisf.h}はFortranで
ライブラリを利用する際に必要なヘッダファイルである. {\tt liblis.a}は生成された
ライブラリファイルである. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Windowsシステムの場合}
{\tt lis-(\$VERSION)/win32}ディレクトリにあるMicrosoft Visual
Studio用ソリューションファイルまたはプロジェクトファイルのうち, 必要なものを使用する. 
{\tt lis\_with\_fortran.sln}は
Intel Visual Fortran Compiler, {\tt lis\_with\_fortran\_mpi.sln}はVisual
Fortran及びMPICH2ライブラリを併用する場合のソリューションファイルである. 
ヘッダファイル は{\tt lis-(\$VERSION)/include}ディレクトリに格納される. 
{\tt lis\_config\_win32.h}はライブラリを生成する際に, また{\tt lis.h}はC, {\tt lisf.h}はFortranで
ライブラリを利用する際に必要なヘッダファイルである. 
生成されたライブラリは{\tt lis-(\$VERSION)/lib}ディレクトリに格納される. 
テストプログラムの実行ファイルは{\tt lis-(\$VERSION)/test}ディレクトリ
に格納される. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{テストプログラム}
\subsubsection{test1}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >test1 matrix_filename rhs_setting solution_filename residual_filename [options]+\\
と入力すると, {\tt matrix\_filename}の示す行列データファイルから行列デー
 タを読み込み, 
線型方程式系$Ax=b$を{\tt options}で指定された解法で解く. また, 
解を{\tt result\_filename}に, 収束履歴を{\tt residual\_filename}に書き出す. 
入力可能な行列データ形式はMatrix Market形式である. 
{\tt rhs\_setting}は
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[0] 行列データファイルに含まれている右辺ベクトルを用いる
\item[1] $b = (1,\dots,1)^T$を用いる
\item[2] $b = A \times (1,\dots,1)^T$を用いる
\item[rhs\_filename] 右辺ベクトルのファイル名
\end{namelist}
が指定できる. {\tt rhs\_filename}はPLAIN形式またはMatrix Market形式が
利用できる. 
{\tt test1f.F}は{\tt test1.c}のFortran版である. 

\subsubsection{test2}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >test2 m n matrix_type solution_filename residual_filename [options]+\\
と入力すると, 2次元Poisson方程式を5点中心差分で離散化して得られる
次数$mn$の5重対角行列を係数とする
線型方程式系$Ax=b$を, \verb|matrix_type| で指定された行列格納形式, 
{\tt options}で指定された解法で解く. また, 
解を{\tt result\_filename}に収束履歴を{\tt residual\_filename}に書き出す. 
ただし, 線型方程式系$Ax=b$の解ベクトルの値がすべて$1$となるように右辺ベクトル$b$を
設定している. $m$, $n$は各次元の格子点数である. 

\subsubsection{test3}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >test3 l m n matrix_type solution_filename residual_filename [options]+\\
と入力すると, 3次元Poisson方程式を7点中心差分で離散化して得られる
次数$lmn$の7重対角行列を係数とする
線型方程式系$Ax=b$を, \verb|matrix_type| で指定された行列格納形式, 
{\tt options}で指定された解法で解く. また, 
解を{\tt result\_filename}に収束履歴を{\tt residual\_filename}に書き出す. 
ただし, 線型方程式系$Ax=b$の解ベクトルの値がすべて$1$となるように右辺ベクトル$b$を
設定している. $l$, $m$, $n$は各次元の格子点数である. 

\subsubsection{test4}
線型方程式系$Ax=b$を指定された解法で解き, 解を表示する. 
行列$A$は次数$12$の3重対角行列
\[
A = 
\left(
\begin{array}{ccccc}
2 & -1 &   &  &   \\
-1 & 2 & -1 &  &   \\
  & \ddots  & \ddots  & \ddots  &   \\
  &   & -1 & 2 & -1 \\
  &   &   & -1 & 2 \\
\end{array}
\right)
\]
である. 右辺ベクトル$b$は解$x$がすべて$1$となるように
求めている. 
{\tt test4f.F}は{\tt test4.c}のFortran版である. 

\subsubsection{test5}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >test5 n gamma [options]+\\
と入力すると, 
線型方程式系$Ax=b$を指定された解法で解き, 解を表示する. 
行列$A$はToepliz行列
\[
A = \left(
\begin{array}{cccccc}
2 & 1 &   &  &  & \\
0 & 2 & 1 &  &  & \\
\gamma & 0& 2 & 1 &  & \\
 & \ddots & \ddots & \ddots & \ddots & \\
 &  &   \gamma &0 &       2   & 1 \\
 &  &  &   \gamma & 0& 2 \\
\end{array}
\right)
\]
である. 右辺ベクトル$b$は解$x$がすべて$1$となるように
求めている. $n$は行列$A$の次数である. 

\subsubsection{etest1}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >etest1 matrix_filename solution_filename residual_filename [options]+\\
と入力すると, {\tt matrix\_filename}の示す行列データファイルから行列データを読み込み, 
固有値問題$Ax=\lambda x$を{\tt options}で指定された解法で解いて, 指定され
 たモードの固有値を表示する. また, 固有値に対応する固有ベクトルを{\tt result\_filename}に, 収束履歴を{\tt residual\_filename}に書き出す. 
入力可能な行列データ形式はMatrix Market形式である. 
{\tt etest1f.F}は{\tt etest1.c}のFortran版である. 

\subsubsection{etest2}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >etest2 m n matrix_type solution_filename residual_filename [options]+\\
と入力すると, 2次元Helmholtz方程式を5点中心差分で離散化して得られる
次数$mn$の5重対角行列に関する固有値問題
$Ax=\lambda x$を, \verb|matrix_type| で指定された行列格納形式, 
{\tt options}で指定された解法で解き, 指定されたモードの固有値を表示する. また, 
固有値に対応する固有ベクトルを{\tt result\_filename}に, 収束履歴を{\tt residual\_filename}に書き出す. 
$m$, $n$は各次元の格子点数である. 

\subsubsection{etest3}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >etest3 l m n matrix_type solution_filename residual_filename [options]+\\
と入力すると, 3次元Helmholtz方程式を7点中心差分で離散化して得られる
次数$lmn$の7重対角行列に関する固有値問題
$Ax=\lambda x$を, \verb|matrix_type| で指定された行列格納形式, 
{\tt options}で指定された解法で解き, 指定されたモードの固有値を表示する. また, 
固有値に対応する固有ベクトルを{\tt result\_filename}に, 収束履歴を{\tt residual\_filename}に書き出す. 
$l$, $m$, $n$は各次元の格子点数である. 

\subsubsection{etest4}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >etest4 n [options]+\\
と入力すると, 固有値問題$Ax=\lambda x$を指定された解法で解き, 指定された
 モードの固有値を表示する. 
行列$A$は次数$n$の3重対角行列
\[
A = 
\left(
\begin{array}{ccccc}
2 & -1 &   &  &   \\
-1 & 2 & -1 &  &   \\
  & \ddots  & \ddots  & \ddots  &   \\
  &   & -1 & 2 & -1 \\
  &   &   & -1 & 2 \\
\end{array}
\right)
\]
である. 
{\tt etest4f.F}は{\tt etest4.c}のFortran版である. 

\subsubsection{etest5}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >etest5 evalue_filename evector_filename +\\
と入力すると, 
固有値問題$Ax=\lambda x$を Subspace Iteration により解き, 絶対値最小の
ものから順に2個の固有値を{\tt evalue\_filename}に, 
対応する固有ベクトルを
{\tt evector\_filename}に拡張Matrix Market形式
 (付録\ref{sec:matinp}を参照) で書き出す. 
行列$A$は次数$12$の3重対角行列
\[
A = 
\left(
\begin{array}{ccccc}
2 & -1 &   &  &   \\
-1 & 2 & -1 &  &   \\
  & \ddots  & \ddots  & \ddots  &   \\
  &   & -1 & 2 & -1 \\
  &   &   & -1 & 2 \\
\end{array}
\right)
\]
である. 

\subsubsection{spmvtest1}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >spmvtest1 n iter+\\
と入力すると, 1次元Poisson方程式を3点中心差分で離散化して
得られる次数$n$の3重対角係数行列
\[
A = 
\left(
\begin{array}{ccccc}
2 & -1 &   &  &   \\
-1 & 2 & -1 &  &   \\
  & \ddots  & \ddots  & \ddots  &   \\
  &   & -1 & 2 & -1 \\
  &   &   & -1 & 2 \\
\end{array}
\right)
\]
とベクトル$(1,\dots,1)^T$との積を, 実行可能な行列格納形式について
{\tt iter}で指定された回数実行し, FLOPS値を算出する. 

\subsubsection{spmvtest2}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >spmvtest2 m n iter+\\
と入力すると, 2次元Poisson方程式を5点中心差分で離散化して得られる
次数$mn$の5重対角係数行列とベクトル
$(1,\dots,1)^T$との積を, 実行可能な行列格納形式について
{\tt iter}で指定された回数実行し, FLOPS値を算出する. 
$m$, $n$は各次元の格子点数である. 

\subsubsection{spmvtest3}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >spmvtest3 l m n iter+\\
と入力すると, 3次元Poisson方程式を7点中心差分で離散化して得られる
次数$lmn$の7重対角係数行列とベクトル
$(1,\dots,1)^T$との積を, 実行可能な行列格納形式について
{\tt iter}で指定された回数実行し, FLOPS値を算出する. 
$l$, $m$, $n$は各次元の格子点数である. 

\subsubsection{spmvtest4}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >spmvtest4 matrix_filename_list iter [block]+\\
と入力すると, {\tt matrix\_filename\_list}の示す行列データ
ファイルリストから行列データを読み込み, 各行列とベクトル
$(1,\dots,1)^T$との積を実行可能な行列格納形式について
$iter$で指定された回数実行し, FLOPS値を算出する. 
必要なら$block$でBSR, BSCのブロックサイズを指定する. 

\subsubsection{spmvtest5}
{\tt lis-(\$VERSION)/test}ディレクトリにおいて\\
 \verb+      >spmvtest5 matrix_filename matrix_type iter [block]+\\
と入力すると, {\tt matrix\_filename}の示す行列データファイル
から行列データを読み込み, 行列とベクトル$(1,\dots,1)^T$との
積を行列格納形式{\tt matrix\_type}について$iter$で
指定された回数実行し, FLOPS値を算出する. 
必要なら$block$でBSR, BSCのブロックサイズを指定する. 

\newpage
\subsection{制限事項}

現在のバージョンには以下の制限がある. 
\begin{itemize}
\item 前処理
\begin{itemize}
\item Jacobi, SSOR以外の前処理が選択され, かつ行列AがCRS形式でない場合,
      前処理作成時にCRS形式の行列Aが作成される.
\item BiCG法を選択した場合, SA-AMG前処理は非対応.
\item SA-AMG前処理はOpenMP環境に非対応, SAINV前処理の前処理行列作成部分は逐次.
\end{itemize}

\item 4倍精度演算
\begin{itemize}
\item 線型方程式系解法のJacobi, Gauss-Seidel, SOR, IDR(s)は非対応.
\item 固有値解法のConjugate Gradient, Conjugate Residualは非対応.
\item Hybrid前処理での内部反復解法のうち, Jacobi, Gauss-Seidel, SORは非対応.
\item I+S, SA-AMG前処理は非対応.
\end{itemize}

\item 行列格納形式
\begin{itemize}
\item MPI環境においてユーザ自身が必要な配列を用意する場合は, CRS形式で作
      成しなければならない.
目的の格納形式を利用するには, \verb|lis_matrix_convert|を使用して
CRS形式から変換する. 
\end{itemize}
\end{itemize}
\vspace*{5mm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{基本操作}
本節では, ライブラリの利用方法について述べる. 
プログラムでは以下の処理を行う必要がある. 
\begin{itemize}
\item 初期化処理
\item 行列の作成
\item ベクトルの作成
\item 線型方程式系または固有値解法のためのソルバ (解法の情報を
      格納する構造体) の作成
\item 行列, ベクトルへの値の代入
\item 解法の設定
\item 求解
\item 終了処理
\end{itemize}
また, プログラムの先頭には以下の{\tt include}文を記述しておかなければならない. 
\begin{itemize}
\item \verb+C       #include "lis.h"+
\item \verb+Fortran #include "lisf.h"+
\end{itemize}
{\tt lis.h}と{\tt lisf.h}は\verb|$(INSTALLDIR)/include|に存在する. 
\newpage
\subsection{初期化・終了処理}
初期化, 終了処理は以下のように記述する. 初期化処理はプログラムの最初に, 
終了処理は最後に必ず実行しなければならない. 
\begin{itembox}[l]{C}
\small
\begin{verbatim}
 1: #include "lis.h"
 2: int main(int argc, char* argv[])
 3: {
 4:     lis_initialize(&argc, &argv);
 5:     ...
 6:     lis_finalize();
 7: }
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran}
\small
\begin{verbatim}
 1: #include "lisf.h"
 2:      call lis_initialize(ierr) 
 3:     ...
 4:      call lis_finalize(ierr)
\end{verbatim}
\end{itembox}
\\ \\
\noindent
{\bf 初期化処理}

初期化処理を行うには関数
\begin{itemize}
\item \verb+C       lis_initialize(int* argc, char** argv[])+
\item \verb+Fortran subroutine lis_initialize(integer ierr)+
\end{itemize}
を用いる. 
この関数は, MPIの初期化, コマンドライン引数の取得等の初期化処理を行う. 
\\ \\
\noindent
{\bf 終了処理}

終了処理を行うには関数
\begin{itemize}
\item \verb+C       int lis_finalize()+
\item \verb+Fortran subroutine lis_finalize(integer ierr)+
\end{itemize}
を用いる. 
\subsection{ベクトル}
ベクトル$v$の次数を$global\_n$とする. 
ベクトル$v$を$nprocs$個のプロセスで行ブロック分割したときの
各部分ベクトルの行数を$local\_n$とする. 
$global\_n$が$nprocs$で割り切れる場合は
$local\_n$ $=$ $global\_n$ $/$ $nprocs$となる. 
例えば, 
ベクトル$v$を(\ref{eq:vecv})式のように2プロセスで行ブロック分割した場合, 
$global\_n$と$local\_n$はそれぞれ$4$と$2$となる. 
\begin{equation}
v = 
\left(
\begin{array}{c}
0 \\
1 \\ \hline
2 \\
3  
\end{array}
\right)
\begin{array}{l}
\mbox{PE0} \\
    \\
\mbox{PE1} \\
   \\ 
\end{array}
\label{eq:vecv}
\end{equation}

(\ref{eq:vecv})式のベクトル$v$を作成する場合, 
逐次, OpenMP版ではベクトル$v$そのものを, MPI版では各プロセスに
プロセス数で行ブロック分割した
部分ベクトルを作成することとなる. 

ベクトル$v$を作成するプログラムは以下のように記述する. ただし, MPI版の
プロセス数は$2$とする. 
\begin{itembox}[l]{C (逐次, OpenMP版)}
\small
\begin{verbatim}
 1: int           i,n;
 2: LIS_VECTOR    v;
 3: n = 4;
 4: lis_vector_create(0,&v);
 5: lis_vector_set_size(v,0,n); /* or lis_vector_set_size(v,n,0); */ 
 6:
 7: for(i=0;i<n;i++)
 8: {
 9:     lis_vector_set_value(LIS_INS_VALUE,i,(double)i,v);
10:  }
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{C (MPI版)}
\small
\begin{verbatim}
 1: int           i,n,is,ie;                 /*or int  i,ln,is,ie;                         /*
 2: LIS_VECTOR    v;
 3: n = 4;                                   /*   ln = 2;                                  */
 4: lis_vector_create(MPI_COMM_WORLD,&v);
 5: lis_vector_set_size(v,0,n);              /*   lis_vector_set_size(v,ln,0);             */
 6: lis_vector_get_range(v,&is,&ie);
 7: for(i=is;i<ie;i++)
 8: {
 9:     lis_vector_set_value(LIS_INS_VALUE,i,(double)i,v);
10:  }
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP版)}
\small
\begin{verbatim}
 1: integer       i,n
 2: LIS_VECTOR    v
 3: n = 4
 4: call lis_vector_create(0,v,ierr)
 5: call lis_vector_set_size(v,0,n,ierr)  
 6:
 7: do i=1,n
 9:     call lis_vector_set_value(LIS_INS_VALUE,i,DBLE(i),v,ierr)
10: enddo
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (MPI版)}
\small
\begin{verbatim}
 1: integer       i,n,is,ie                 
 2: LIS_VECTOR    v
 3: n = 4                                   
 4: call lis_vector_create(MPI_COMM_WORLD,v,ierr)
 5: call lis_vector_set_size(v,0,n,ierr)              
 6: call lis_vector_get_range(v,is,ie,ierr)
 7: do i=is,ie-1
 8:     call lis_vector_set_value(LIS_INS_VALUE,i,DBLE(i),v,ierr);
 9: enddo
\end{verbatim}
\end{itembox}
\newpage
\noindent
{\bf 変数宣言}

2行目のように\\
\verb|    LIS_VECTOR    v;|\\
と宣言する. 
\\ \\
\noindent
{\bf ベクトルの作成}

ベクトル$v$の作成は関数
\begin{itemize}
\item \verb|C       int lis_vector_create(LIS_Comm comm, LIS_VECTOR *vec)|
\item \verb|Fortran subroutine lis_vector_create(LIS_Comm comm, LIS_VECTOR vec, integer ierr)|
\end{itemize}
を用いる. 
{\tt comm}にはMPIコミュニケータを指定する. 逐次, OpenMP版では{\tt comm}の値は無視される. 
\\ \\
\noindent
{\bf ベクトルサイズの設定}

ベクトルサイズの設定は関数
\begin{itemize}
\item \verb|C       int lis_vector_set_size(LIS_VECTOR vec, int local_n, int global_n)|
\item \verb|Fortran subroutine lis_vector_set_size(LIS_VECTIR vec, integer local_n,| \\
      \verb|         integer global_n, integer ierr)|
\end{itemize}
を用いる. 
$local\_n$ か $global\_n$ のどちらか一方を与えなければならない. 

逐次, OpenMP版では, ベクトルの次数は$local\_n$ $=$ $global\_n$となる. 
したがって, \\
\verb|lis_vector_set_size(v,n,0)|
と\verb|lis_vector_set_size(v,0,n)|はどちらも次数$n$のベクトルを作成することを意味する. 

MPI版では, \verb|lis_vector_set_size(v,n,0)|とすると, 
各プロセス$p$に次数$n$の部分ベクトルを作成する. 
一方, \verb|lis_vector_set_size(v,0,n)|とすると
各プロセス$p$に次数$m_p$の部分ベクトルを作成する. ただし, $m_p$の値はライブラリ側で決定される. 
\\ \\
\noindent
{\bf 要素の代入}

ベクトル$v$の$i$行目に要素を代入するには関数
\begin{itemize}
\item \verb|C       int lis_vector_set_value(int flag, int i, LIS_SCALAR value, LIS_VECTOR v)|
\item \verb|Fortran subroutine lis_vector_set_value(int flag, int i, LIS_SCALAR value,|\\
      \verb|         LIS_VECTOR v, integer ierr)|
\end{itemize}
を用いる. MPI版では, 部分ベクトルの$i$行目ではなく全体ベクトルの$i$行目を指定する. 
\verb+flag+には
\begin{description}
\item[\tt LIS\_INS\_VALUE] 挿入: {\tt v($i$) = $value$}
\item[\tt LIS\_ADD\_VALUE] 加算代入: {\tt v($i$) = v($i$) + $value$}
\end{description}
のどちらかを指定する 
\\ \\
\noindent
{\bf ベクトルの複製}

既存のベクトルと同じ情報を持つベクトルを作成するには関数
\begin{itemize}
\item \verb|C       int lis_vector_duplicate(LIS_VECTOR vin, LIS_VECTOR *vout)|
\item \verb|Fortran subroutine lis_vector_duplicate(LIS_VECTOR vin, LIS_VECTOR vout,|\\
      \verb|         integer ierr)|
\end{itemize}
を用いる. 第1引数\verb|LIS_VECTOR vin|は\verb|LIS_MATRIX|を指定することも可能である. 
この関数はベクトルの要素はコピーしない. 要素もコピーしたい場合は
この関数の後に
\begin{itemize}
\item \verb|C       int lis_vector_copy(LIS_VECTOR vsrc, LIS_VECTOR vdst)|
\item \verb|Fortran subroutine lis_vector_copy(LIS_VECTOR vsrc, LIS_VECTOR vdst, integer ierr)|
\end{itemize}
を用いる. 
\\ \\
\noindent
{\bf ベクトルの破棄}

不要になったベクトルをメモリから破棄するには
\begin{itemize}
\item \verb|C       int lis_vector_destroy(LIS_VECTOR v)|
\item \verb|Fortran subroutine lis_vector_destroy(LIS_VECTOR vec, integer ierr)|
\end{itemize}
を用いる. 
\subsection{行列}
係数行列$A$の次数を$global\_n$ $\times$ $global\_n$とする. 
行列$A$を$nprocs$個のプロセスで行ブロック分割したときの
各ブロックの行数を$local\_n$とする. 
$global\_n$が$nprocs$で割り切れる場合は
$local\_n$ $=$ $global\_n$ $/$ $nprocs$となる. 
例えば, 
行列$A$を(\ref{eq:mat})式のように2個のプロセスで行ブロック分割した場合, 
$global\_n$と$local\_n$はそれぞれ$4$と$2$となる. 
\begin{equation}
\label{eq:mat}
A = 
\left(
\begin{array}{cccc}
2 & 1 &   &    \\
1 & 2 & 1 &    \\ \hline
  & 1 & 2 & 1 \\
  &   & 1 & 2 
\end{array}
\right)
\begin{array}{l}
\mbox{PE0} \\
    \\
\mbox{PE1} \\
   \\ 
\end{array}
\end{equation}

目的の格納形式の行列を作成するには以下の3つの方法がある.\\ \\
\noindent
{\bf 方法1: ライブラリ関数を用いて目的の格納形式に必要な配列を定義する場合}\\
(\ref{eq:mat})式の行列$A$をCRS形式で作成する場合, 
逐次, OpenMP版では行列$A$そのものを, MPI版では各プロセスに
プロセス数で行ブロック分割した
部分行列を作成することとなる. 

行列$A$をCRS形式で作成するプログラムは以下のように記述する. 
ただし, MPI版のプロセス数は$2$とする. 
\begin{itembox}[l]{C (逐次, OpenMP版)}
\small
\begin{verbatim}
 1: int           i,n;
 2: LIS_MATRIX    A;
 3: n = 4;
 4: lis_matrix_create(0,&A);
 5: lis_matrix_set_size(A,0,n); /* or lis_matrix_set_size(A,n,0); */ 
 6: for(i=0;i<n;i++) {
 7:     if( i>0   ) lis_matrix_set_value(LIS_INS_VALUE,i,i-1,1.0,A);
 8:     if( i<n-1 ) lis_matrix_set_value(LIS_INS_VALUE,i,i+1,1.0,A);
 9:     lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0,A);
10:  }
11:  lis_matrix_set_type(A,LIS_MATRIX_CRS);
12:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{C (MPI版)}
\small
\begin{verbatim}
 1: int           i,n,gn,is,ie;                 
 2: LIS_MATRIX    A;
 3: gn = 4;                                  /* or n=2                         */
 4: lis_matrix_create(MPI_COMM_WORLD,&A);
 5: lis_matrix_set_size(A,0,gn);             /*    lis_matrix_set_size(A,n,0); */
 6: lis_matrix_get_size(A,&n,&gn);
 7: lis_matrix_get_range(A,&is,&ie);
 8: for(i=is;i<ie;i++) {
 9:     if( i>0    ) lis_matrix_set_value(LIS_INS_VALUE,i,i-1,1.0,A);
10:     if( i<gn-1 ) lis_matrix_set_value(LIS_INS_VALUE,i,i+1,1.0,A);
11:     lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0,A);
12:  }
13:  lis_matrix_set_type(A,LIS_MATRIX_CRS);
14:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP版)}
\small
\begin{verbatim}
 1: integer       i,n
 2: LIS_MATRIX    A
 3: n = 4
 4: call lis_matrix_create(0,A,ierr)
 5: call lis_matrix_set_size(A,0,n,ierr)
 6: do i=1,n
 7:     if( i>1 ) call lis_matrix_set_value(LIS_INS_VALUE,i,i-1,1.0d0,A,ierr)
 8:     if( i<n ) call lis_matrix_set_value(LIS_INS_VALUE,i,i+1,1.0d0,A,ierr)
 9:     call lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0d0,A,ierr)
10:  enddo
11:  call lis_matrix_set_type(A,LIS_MATRIX_CRS,ierr)
12:  call lis_matrix_assemble(A,ierr)
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (MPI版)}
\small
\begin{verbatim}
 1: integer       i,n,gn,is,ie                 
 2: LIS_MATRIX    A
 3: gn = 4
 4: call lis_matrix_create(MPI_COMM_WORLD,A,ierr)
 5: call lis_matrix_set_size(A,0,gn,ierr)
 6: call lis_matrix_get_size(A,n,gn,ierr)
 7: call lis_matrix_get_range(A,is,ie,ierr)
 8: do i=is,ie-1
 9:     if( i>1  ) call lis_matrix_set_value(LIS_INS_VALUE,i,i-1,1.0d0,A,ierr)
10:     if( i<gn ) call lis_matrix_set_value(LIS_INS_VALUE,i,i+1,1.0d0,A,ierr)
11:     call lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0d0,A,ierr)
12:  enddo
13:  call lis_matrix_set_type(A,LIS_MATRIX_CRS,ierr)
14:  call lis_matrix_assemble(A,ierr)
\end{verbatim}
\end{itembox}
\\ \\
\noindent
{\bf 変数宣言}

2行目のように\\
\verb|    LIS_MATRIX    A;|\\
と宣言する. 
\\ \\
\noindent
{\bf 行列の作成}

行列$A$の作成は関数
\begin{itemize}
\item \verb|C       int lis_matrix_create(LIS_Comm comm, LIS_MATRIX *A)|
\item \verb|Fortran subroutine lis_matrix_create(LIS_Comm comm, LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 
{\tt comm}にはMPIコミュニケータを指定する. 逐次, OpenMP版では, {\tt comm}の値は無視される. 
\\ \\
\noindent
{\bf 行列のサイズ設定}

行列$A$のサイズ設定は関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_size(LIS_MATRIX A, int local_n, int global_n)|
\item \verb|Fortran subroutine lis_matrix_set_size(LIS_MATRIX A, integer local_n,|\\
      \verb|         integer global_n, integer ierr)|
\end{itemize}
を用いる. 
$local\_n$ か $global\_n$ のどちらか一方を与えなければならない. 

逐次, OpenMP版では, 行列のサイズは$local\_n$ $=$ $global\_n$となる. 
したがって, \\
\verb|lis_matrix_set_size(A,n,0)|
と\verb|lis_matrix_set_size(A,0,n)|はともに$n \times n$のサイズを設定することを意味する. 

MPI版では, \verb|lis_matrix_set_size(A,n,0)|とすると, 
各プロセス$p$で行列サイズが$n_p \times N$となるように設定する. ここで, $N$
は各プロセスの$n_p$の
総和である. \\
一方, \verb|lis_matrix_set_size(A,0,n)|とすると
各プロセス$p$で行列サイズが$m_p \times n$となるように設定する. ここで, $m_p$は部分行列の行数で
この値はライブラリ側で決定される. 
\\ \\
\noindent
{\bf 要素の代入}

行列$A$の$i$行$j$列目に要素を代入するには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_value(int flag, int i, int j, LIS_SCALAR value,|\\
      \verb|         LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_value(integer flag, integer i, integer j,|\\
      \verb|         LIS_SCALAR value, LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. MPI版では, 部分行列の$i$行$j$列目ではなく全体行列の$i$行$j$列目を指定する. 
flagには
\begin{description}
\item[\tt LIS\_INS\_VALUE] 挿入: $A(i,j) = value$
\item[\tt LIS\_ADD\_VALUE] 加算代入: $A(i,j) = A(i,j) + value$
\end{description}
のどちらかを指定する 
\\ \\
\noindent
{\bf 行列格納形式の設定}

行列の格納形式を設定するには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_type(LIS_MATRIX A, int matrix_type)|
\item \verb|Fortran subroutine lis_matrix_set_type(LIS_MATRIX A, int matrix_type, integer ierr)|
\end{itemize}
を用いる. 
行列作成時に $A$ の \verb+matrix_type+ は \verb+LIS_MATRIX_CRS+ となっている. 
以下に \verb+matrix_type+ に指定可能な格納形式を示す. 
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{lll}\hline\hline
格納形式  & & matrix\_type \\ \hline
Compressed Row Storage & (CRS) & \verb={LIS_MATRIX_CRS|1}= \\
Compressed Column Storage & (CCS) & \verb={LIS_MATRIX_CCS|2}= \\
Modified Compressed Sparse Row & (MSR) & \verb={LIS_MATRIX_MSR|3}= \\
Diagonal &(DIA) & \verb={LIS_MATRIX_DIA|4}= \\
Ellpack-Itpack generalized diagonal &(ELL) & \verb={LIS_MATRIX_ELL|5}= \\
Jagged Diagonal &(JDS) & \verb={LIS_MATRIX_JDS|6}= \\
Block Sparse Row & (BSR) & \verb={LIS_MATRIX_BSR|7}= \\
Block Sparse Column &(BSC) & \verb={LIS_MATRIX_BSC|8}= \\
Variable Block Row &(VBR) & \verb={LIS_MATRIX_VBR|9}= \\
Dense &	(DNS) & \verb={LIS_MATRIX_DNS|10}= \\
Coordinate & (COO) & \verb={LIS_MATRIX_COO|11}= \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\noindent
{\bf 行列の組み立て}

行列の要素をすべて代入したら, 必ず関数
\begin{itemize}
\item \verb|C       int lis_matrix_assemble(LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_assemble(LIS_MATRIX A, integer ierr)|
\end{itemize}
を呼び出す. 
\verb|lis_matrix_assemble| は \verb|lis_matrix_set_type| で指定された格納形式に組み立てられる. 
\\ \\ \\
\noindent
{\bf 行列の破棄}

不要になった行列をメモリから破棄するには
\begin{itemize}
\item \verb|C       int lis_matrix_destroy(LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_destroy(LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 
\\ \\
{\bf 方法2: 目的の格納形式に必要な配列を直接定義する場合}\\
(\ref{eq:mat})式の行列$A$をCRS形式で作成する場合, 
逐次, OpenMP版では行列$A$そのものを, MPI版では各プロセスに
プロセス数で行ブロック分割した
部分行列を作成することとなる. 

行列$A$をCRS形式で作成するプログラムは以下のように記述する. 
ただし, MPI版のプロセス数は$2$とする. 
\begin{itembox}[l]{C (逐次, OpenMP版)}
\small
\begin{verbatim}
 1: int           i,k,n,nnz;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 10; k = 0;
 6: lis_matrix_malloc_crs(n,nnz,&ptr,&index,&value);
 7: lis_matrix_create(0,&A);
 8: lis_matrix_set_size(A,0,n);  /* or lis_matrix_set_size(A,n,0); */ 
 9: 
10: for(i=0;i<n;i++)
11: {
12:     if( i>0   ) {index[k] = i-1; value[k] = 1; k++;}
13:     index[k] = i; value[k] = 2; k++;
14:     if( i<n-1 ) {index[k] = i+1; value[k] = 1; k++;}
15:     ptr[i+1] = k;
16:  }
17:  ptr[0] = 0;
18:  lis_matrix_set_crs(nnz,ptr,index,value,A);
19:  lis_matrix_assemble(A); 


\end{verbatim}
\end{itembox}
\begin{itembox}[l]{C (MPI版)}
\small
\begin{verbatim}
 1: int           i,k,n,nnz,is,ie;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 2; nnz = 5; k = 0;
 6: lis_matrix_malloc_crs(n,nnz,&ptr,&index,&value);
 7: lis_matrix_create(MPI_COMM_WORLD,&A);
 8: lis_matrix_set_size(A,n,0);
 9: lis_matrix_get_range(A,&is,&ie);
10: for(i=is;i<ie;i++)
11: {
12:     if( i>0   ) {index[k] = i-1; value[k] = 1; k++;}
13:     index[k] = i; value[k] = 2; k++;
14:     if( i<n-1 ) {index[k] = i+1; value[k] = 1; k++;}
15:     ptr[i-is+1] = k;
16:  }
17:  ptr[0] = 0;
18:  lis_matrix_set_crs(nnz,ptr,index,value,A);
19:  lis_matrix_assemble(A); 
\end{verbatim}
\end{itembox}
\\ \\
\noindent
{\bf 配列の関連付け}

ユーザ自身が作成したCRS形式に必要な配列をライブラリが扱えるよう行列$A$に
関連付けるには, 関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_crs(int nnz, int row[], int index[], LIS_SCALAR value[],|\\
      \verb|         LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_crs(integer nnz, integer row(), integer index(),|\\
      \verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 
その他の格納形式については第\ref{sec:storages}節を参照せよ. 
\\ \\
{\bf 方法3: 外部ファイルから行列, ベクトルデータを読み込む場合}\\
外部ファイルから(\ref{eq:mat})式の行列$A$をCRS形式で読み込む場合のプログラムは以下のように記述する. 
\begin{itembox}[l]{C (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX    A;
 3: lis_matrix_create(LIS_COMM_WORLD,&A); 
 6: lis_matrix_set_type(A,LIS_MATRIX_CRS); 
 7: lis_input_matrix(A,"matvec.mtx"); 
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX    A
 3: call lis_matrix_create(LIS_COMM_WORLD,A,ierr) 
 6: call lis_matrix_set_type(A,LIS_MATRIX_CRS,ierr) 
 7: call lis_input_matrix(A,'matvec.mtx',ierr) 
\end{verbatim}
\end{itembox}
\\ \\
Matrix Market形式による外部ファイル{\tt matvec.mtx}の記述例を以下に示す. 
{\small
\begin{verbatim}
%%MatrixMarket matrix coordinate real general
4 4 10 1 0
1 2  1.0e+00
1 1  2.0e+00
2 3  1.0e+00
2 1  1.0e+00
2 2  2.0e+00
3 4  1.0e+00
3 2  1.0e+00
3 3  2.0e+00
4 4  2.0e+00
4 3  1.0e+00
\end{verbatim}
}

外部ファイルから(\ref{eq:mat})式の行列$A$をCRS形式で, また(\ref{eq:vecv})式のベクトル$b$を読み込む
場合のプログラムは以下のように記述する. 
\begin{itembox}[l]{C (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX    A;
 2: LIS_VECTOR    b,x;
 3: lis_matrix_create(LIS_COMM_WORLD,&A); 
 4: lis_vector_create(LIS_COMM_WORLD,&b); 
 5: lis_vector_create(LIS_COMM_WORLD,&x); 
 6: lis_matrix_set_type(A,LIS_MATRIX_CRS); 
 7: lis_input(A,b,x,"matvec.mtx"); 
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX    A
 2: LIS_VECTOR    b,x
 3: call lis_matrix_create(LIS_COMM_WORLD,A,ierr) 
 4: call lis_vector_create(LIS_COMM_WORLD,b,ierr) 
 5: call lis_vector_create(LIS_COMM_WORLD,x,ierr) 
 6: call lis_matrix_set_type(A,LIS_MATRIX_CRS,ierr) 
 7: call lis_input(A,b,x,'matvec.mtx',ierr) 
\end{verbatim}
\end{itembox}
\\ \\
拡張Matrix Market形式による外部ファイル{\tt matvec.mtx}の記述例を以下に
示す (付録\ref{sec:matinp}を参照). 
{\small
\begin{verbatim}
%%MatrixMarket matrix coordinate real general
4 4 10 1 0
1 2  1.0e+00
1 1  2.0e+00
2 3  1.0e+00
2 1  1.0e+00
2 2  2.0e+00
3 4  1.0e+00
3 2  1.0e+00
3 3  2.0e+00
4 4  2.0e+00
4 3  1.0e+00
1  0.0e+00
2  1.0e+00
3  2.0e+00
4  3.0e+00
\end{verbatim}
}

\noindent
{\bf 外部ファイルからの読み込み}

外部ファイルから行列$A$のデータを読み込むには, 関数
\begin{itemize}
\item \verb|C       int lis_input_matrix(LIS_MATRIX A, char *filename)|
\item \verb|Fortran subroutine lis_input_matrix(LIS_MATRIX A, |\\
      \verb|         character filename, integer ierr)|
\end{itemize}
を用いる. {\tt filename}にはファイルパスを指定する. 
対応するファイル形式は以下の通りである (ファイル形式については付録\ref{sec:matinp}を参照). 
\begin{itemize}
\item Matrix Market形式
\item Harwell-Boeing形式
\end{itemize}

外部ファイルから行列$A$とベクトル$b$, $x$のデータを読み込むには, 関数
\begin{itemize}
\item \verb|C       int lis_input(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x, char *filename)|
\item \verb|Fortran subroutine lis_input(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
      \verb|         character filename, integer ierr)|
\end{itemize}
を用いる. {\tt filename}にはファイルパスを指定する. 
対応するファイル形式は以下の通りである (ファイル形式については付録\ref{sec:matinp}を参照). 
\begin{itemize}
\item 拡張Matrix Market形式 (ベクトルデータに対応) 
\item Harwell-Boeing形式
\end{itemize}

\subsection{線型方程式系の求解}\label{subsec:solve}
線型方程式系$Ax=b$を指定された解法で解くプログラムは以下のように記述する. 
\begin{itembox}[l]{C (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX A; 
 2: LIS_VECTOR b,x; 
 3: LIS_SOLVER solver; 
 4:    
 5: /* 行列とベクトルの作成 */ 
 6:    
 7: lis_solver_create(&solver); 
 8: lis_solver_set_option("-i bicg -p none",solver); 
 9: lis_solver_set_option("-tol 1.0e-12",solver); 
10: lis_solve(A,b,x,solver); 
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX A 
 2: LIS_VECTOR b,x 
 3: LIS_SOLVER solver 
 4:    
 5: /* 行列とベクトルの作成 */ 
 6:    
 7: call lis_solver_create(solver,ierr) 
 8: call lis_solver_set_option('-i bicg -p none',solver,ierr) 
 9: call lis_solver_set_option('-tol 1.0e-12',solver,ierr) 
10: call lis_solve(A,b,x,solver,ierr) 
\end{verbatim}
\end{itembox}
\\ \\
\noindent
{\bf ソルバの作成}

ソルバ (線型方程式系解法の情報を格納する構造体) を作成するには関数
\begin{itemize}
\item \verb|C       int lis_solver_create(LIS_SOLVER *solver)|
\item \verb|Fortran subroutine lis_solver_create(LIS_SOLVER solver, integer ierr) |
\end{itemize}
を用いる. 
\\ \\
\noindent
{\bf オプションの設定}

線型方程式系解法をソルバに設定するには関数 
\begin{itemize}
\item \verb|C       int lis_solver_set_option(char *text, LIS_SOLVER solver)|
\item \verb|Fortran subroutine lis_solver_set_option(character text, LIS_SOLVER solver,|\\
      \verb|         integer ierr)|
\end{itemize}
または
\begin{itemize}
\item \verb|C       int lis_solver_set_optionC(LIS_SOLVER solver)|
\item \verb|Fortran subroutine lis_solver_set_optionC(LIS_SOLVER solver, integer ierr)|
\end{itemize}
を用いる. 
\verb|lis_solver_set_optionC|はユーザプログラム実行時にコマンドラインで
指定されたオプションをソルバに設定する関数である. 

以下に指定可能なコマンドラインオプションを示す. \verb=-i {cg|1}=は\verb=-i cg=または\verb=-i 1=
を意味する. \\
\verb=-maxiter [1000]=は\verb=-maxiter=のデフォルト値が$1000$であることを意味する. 
\\
\\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 線型方程式系解法の指定} デフォルト: \verb=-i bicg= \\
\begin{tabular}{l|lll}\hline\hline
 線型方程式系解法        & オプション              &  補助オプション  & \\ \hline
 CG          & \verb=-i {cg|1}=         &    \\ 
 BiCG        & \verb=-i {bicg|2}=       &    \\
 CGS         & \verb=-i {cgs|3}=        &    \\
 BiCGSTAB    & \verb=-i {bicgstab|4}=   &    \\
 BiCGSTAB(l) & \verb=-i {bicgstabl|5}=  & \verb=-ell [2]=      & 次数$l$ \\
 GPBiCG      & \verb=-i {gpbicg|6}=     &    \\
 TFQMR       & \verb=-i {tfqmr|7}=      &    \\
 Orthomin(m) & \verb=-i {orthomin|8}=   & \verb=-restart [40]= & リスタート値$m$  \\
 GMRES(m)    & \verb=-i {gmres|9}=      & \verb=-restart [40]= & リスタート値$m$  \\ 
 Jacobi      & \verb=-i {jacobi|10}=    &    \\
 Gauss-Seidel& \verb=-i {gs|11}=        &    \\
 SOR         & \verb=-i {sor|12}=       & \verb=-omega [1.9]=  & 緩和係数$\omega$ ($0<\omega<2$) \\
 BiCGSafe    & \verb=-i {bicgsafe|13}=  &    \\
 CR          & \verb=-i {cr|14}=        &    \\ 
 BiCR        & \verb=-i {bicr|15}=      &    \\
 CRS         & \verb=-i {crs|16}=       &    \\
 BiCRSTAB    & \verb=-i {bicrstab|17}=  &    \\
 GPBiCR      & \verb=-i {gpbicr|18}=    &    \\
 BiCRSafe    & \verb=-i {bicrsafe|19}=  &    \\
 FGMRES(m)   & \verb=-i {fgmres|20}=    & \verb=-restart [40]= & リスタート値$m$  \\ 
 IDR(s)      & \verb=-i {idrs|21}=      & \verb=-irestart [2]= & リスタート値$s$  \\ 
 MINRES      & \verb=-i {minres|22}=    &    \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 前処理の指定} デフォルト: \verb=-p none=\\
\begin{tabular}{l|lll}\hline\hline
前処理   & オプション           & 補助オプション \\ \hline
なし     & \verb=-p {none|0}=    &   \\
Jacobi   & \verb=-p {jacobi|1}=  &     \\
ILU(k)   & \verb=-p {ilu|2}=     & \verb=-ilu_fill [0]=    & フィルインレベル$k$ \\
SSOR     & \verb=-p {ssor|3}=    & \verb=-ssor_w [1.0]=    & 緩和係数$\omega$ ($0<\omega<2$) \\
Hybrid   & \verb=-p {hybrid|4}=  & \verb=-hybrid_i [sor]=  & 線型方程式系解法 \\
         &                       & \verb=-hybrid_maxiter [25]= & 最大反復回数 \\
         &                       & \verb=-hybrid_tol [1.0e-3]= & 収束判定基準 \\
         &                       & \verb=-hybrid_w [1.5]=      & SORの緩和係数$\omega$ ($0<\omega<2$) \\
         &                       & \verb=-hybrid_ell [2]=      & BiCGSTAB(l)の次数$l$\\
         &                       & \verb=-hybrid_restart [40]= & GMRES(m), Orthomin(m)の \\
         &                       &                             & リスタート値$m$ \\
I+S      & \verb=-p {is|5}=      & \verb=-is_alpha [1.0]=  & $I+\alpha S^{(m)}$型前処理のパラメータ$\alpha$ \\
         &                       & \verb=-is_m [3]=        & $I+\alpha S^{(m)}$型前処理のパラメータ$m$ \\
SAINV    & \verb=-p {sainv|6}=   & \verb=-sainv_drop [0.05]=    & ドロップ基準\\
SA-AMG   & \verb=-p {saamg|7}=   & \verb=-saamg_unsym [false]=     & 非対称版の選択 \\
         &                       &                                 & (行列構造は対称とする) \\
         &                       & \verb=-saamg_theta [0.05|0.12]= & ドロップ基準 $a^2_{ij}\le\theta^2|a_{ii}||a_{jj}|$ \\
         &                       &                             & (対称\verb=|=非対称) \\
Crout ILU& \verb=-p {iluc|8}=    & \verb=-iluc_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-iluc_rate [5.0]=     & 最大フィルイン数の倍率 \\
ILUT     & \verb=-p {ilut|9}=    & \verb=-ilut_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-ilut_rate [5.0]=     & 最大フィルイン数の倍率 \\
Additive Schwarz  & \verb=-adds true=   &  \verb=-adds_iter [1]= & 繰り返し回数   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf その他のオプション}\\
\begin{tabular}{l|ll}\hline\hline
オプション &                          \\ \hline
\verb=-maxiter [1000]= & 最大反復回数         \\ 
\verb=-tol [1.0e-12]=  & 収束判定基準              \\
\verb=-print [0]=      & 残差の画面表示                 \\
                       & \verb=-print {none|0}     =  何もしない \\
                       & \verb=-print {mem|1}      =  収束履歴をメモリに保存する\\
                       & \verb=-print {out|2}      =  収束履歴を画面に表示する\\
                       & \verb=-print {all|3}      =  収束履歴をメモリに保存し画面に表示する\\
\verb=-scale [0]=      & スケーリングの選択. 結果は元の行列, ベクトルに上書きされる \\
                       & \verb=-scale {none|0}     =  スケーリングなし \\ 
                       & \verb=-scale {jacobi|1}   =  Jacobiスケーリング $D^{-1}Ax=D^{-1}b$ \\
                       & \verb=                    =  ($D$は$A=(a_{ij})$の対角部分)\\
                       & \verb=-scale {symm_diag|2}=  対角スケーリング $D^{-1/2}AD^{-1/2}x=D^{-1/2}b$ \\
                       & \verb=                    =  ($D^{-1/2}$は対角要素に$1/\sqrt{a_{ii}}$を持つ対角行列) \\ 
\verb=-initx_zeros [true]= & 初期ベクトル$x_{0}$の振舞い  \\
                       & \verb=-initx_zeros {false|0}     =  与えられた値を使用 \\
                       & \verb=-initx_zeros {true|1}      =  すべての要素を$0$にする\\
\verb=-omp_num_threads [t]= & 実行スレッド数         \\ 
                            & (\verb=t=は最大スレッド数) \\
\verb=-storage [0]=    & 行列格納形式 \\
\verb=-storage_block [2]= & BSR, BSCのブロックサイズ \\ 
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 演算精度の指定} デフォルト: \verb=-f double=\\
\begin{tabular}{l|lll}\hline\hline
精度     & オプション           & 補助オプション \\ \hline
倍精度   & \verb=-f {double|0}=    &   \\
4倍精度  & \verb=-f {quad|1}=    &   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\ \\
\noindent
{\bf 求解}

線型方程式系$Ax=b$を解くには, 関数
\begin{itemize}
\item \verb|C       int lis_solve(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x, LIS_SOLVER solver)|
\item \verb|Fortran subroutine lis_solve(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
      \verb|         LIS_SOLVER solver, integer ierr)|
\end{itemize}
を用いる. 

\subsection{固有値問題の求解}\label{subsec:esolve}
固有値問題$Ax=\lambda x$を指定の解法で解くプログラムは以下のように記述する. 
\begin{itembox}[l]{C (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX A; 
 2: LIS_VECTOR x; 
 3: LIS_REAL evalue; 
 4: LIS_ESOLVER esolver; 
 5:    
 6: /* 行列とベクトルの作成 */ 
 7:    
 8: lis_esolver_create(&esolver); 
 9: lis_esolver_set_option("-e ii -i bicg -p none",esolver); 
10: lis_esolver_set_option("-etol 1.0e-12 -tol 1.0e-12",esolver); 
11: lis_esolve(A,x,evalue,esolver); 
\end{verbatim}
\end{itembox}
\begin{itembox}[l]{Fortran (逐次, OpenMP, MPI版)}
\small
\begin{verbatim}
 1: LIS_MATRIX A 
 2: LIS_VECTOR x 
 3: LIS_REAL evalue
 4: LIS_ESOLVER esolver 
 5:    
 6: /* 行列とベクトルの作成 */ 
 7:    
 8: call lis_esolver_create(esolver,ierr) 
 9: call lis_esolver_set_option('-e ii -i bicg -p none',esolver,ierr) 
10: call lis_esolver_set_option('-etol 1.0e-12 -tol 1.0e-12',esolver,ierr) 
11: call lis_esolve(A,x,evalue,esolver,ierr) 
\end{verbatim}
\end{itembox}
\\ \\
\noindent
{\bf ソルバの作成}

ソルバ (固有値解法の情報を格納する構造体) を作成するには関数
\begin{itemize}
\item \verb|C       int lis_esolver_create(LIS_ESOLVER *esolver)|
\item \verb|Fortran subroutine lis_esolver_create(LIS_ESOLVER esolver, integer ierr) |
\end{itemize}
を用いる. 
\\ \\
\noindent
{\bf オプションの設定}

固有値解法をソルバに設定するには関数 
\begin{itemize}
\item \verb|C       int lis_esolver_set_option(char *text, LIS_ESOLVER esolver)|
\item \verb|Fortran subroutine lis_esolver_set_option(character text, LIS_ESOLVER esolver,|\\
      \verb|         integer ierr)|
\end{itemize}
または
\begin{itemize}
\item \verb|C       int lis_esolver_set_optionC(LIS_ESOLVER esolver)|
\item \verb|Fortran subroutine lis_esolver_set_optionC(LIS_ESOLVER esolver, integer ierr)|
\end{itemize}
を用いる. 
\verb|lis_esolver_set_optionC|はユーザプログラム実行時にコマンドラインで
指定されたオプションをソルバに設定する関数である. 

{\bf オプションの設定}

固有値解法をソルバに設定するには関数 
\begin{itemize}
\item \verb|C       int lis_esolver_set_option(char *text, LIS_ESOLVER esolver)|
\item \verb|Fortran subroutine lis_esolver_set_option(character text, LIS_ESOLVER esolver,|\\
      \verb|         integer ierr)|
\end{itemize}
または
\begin{itemize}
\item \verb|C       int lis_esolver_set_optionC(LIS_ESOLVER esolver)|
\item \verb|Fortran subroutine lis_esolver_set_optionC(LIS_ESOLVER esolver, integer ierr)|
\end{itemize}
を用いる. 
\verb|lis_esolver_set_optionC|はユーザプログラム実行時にコマンドラインで
指定されたオプションをソルバに設定する関数である. 

以下に指定可能なコマンドラインオプションを示す. \verb=-e {pi|1}=は\verb=-e pi=または\verb=-e 1=
を意味する. \\
\verb=-emaxiter [1000]=は\verb=-emaxiter=のデフォルト値が$1000$であることを意味する. 
\\
\\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 固有値解法の指定} デフォルト: \verb=-e pi= \\
\begin{tabular}{l|lll}\hline\hline
 固有値解法               & オプション              &  補助オプション    & \\ \hline
 Power Iteration                   & \verb=-e {pi|1}=        &    \\ 
 Inverse Iteration                 & \verb=-e {ii|2}=        &    \verb=-i [bicg]= & 線型方程式系解法 \\
 Approximate Inverse Iteration     & \verb=-e {aii|3}=       &    \\
 Rayleigh Quotient Iteration       & \verb=-e {rqi|4}=       &    \verb=-i [bicg]= & 線型方程式系解法 \\
 Subspace Iteration                & \verb=-e {si|5}=        &    \verb=-ss [2]= & 部分空間の大きさ \\
                                   &                         &    \verb=-m [0]= & モード番号 \\
 Lanczos Iteration                 & \verb=-e {li|6}=        &    \verb=-ss [2]= & 部分空間の大きさ \\
                                   &                         &    \verb=-m [0]= & モード番号 \\
 Conjugate Gradient                & \verb=-e {cg|7}=        &    \\
 Conjugate Residual                & \verb=-e {cr|8}=        &    \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 前処理の指定} デフォルト: \verb=-p ilu=\\
\begin{tabular}{l|lll}\hline\hline
前処理   & オプション           & 補助オプション \\ \hline
なし     & \verb=-p {none|0}=    &   \\
Jacobi   & \verb=-p {jacobi|1}=  &     \\
ILU(k)   & \verb=-p {ilu|2}=     & \verb=-ilu_fill [0]=    & フィルインレベル$k$ \\
SSOR     & \verb=-p {ssor|3}=    & \verb=-ssor_w [1.0]=    & 緩和係数$\omega$ ($0<\omega<2$) \\
Hybrid   & \verb=-p {hybrid|4}=  & \verb=-hybrid_i [sor]=  & 線型方程式系解法 \\
         &                       & \verb=-hybrid_maxiter [25]= & 最大反復回数 \\
         &                       & \verb=-hybrid_tol [1.0e-3]= & 収束判定基準 \\
         &                       & \verb=-hybrid_w [1.5]=      & SORの緩和係数$\omega$ ($0<\omega<2$) \\
         &                       & \verb=-hybrid_ell [2]=      & BiCGSTAB(l)の次数$l$\\
         &                       & \verb=-hybrid_restart [40]= & GMRES(m), Orthomin(m)の \\
         &                       &                             & リスタート値$m$ \\
I+S      & \verb=-p {is|5}=      & \verb=-is_alpha [1.0]=  & $I+\alpha S^{(m)}$型前処理のパラメータ$\alpha$ \\
         &                       & \verb=-is_m [3]=        & $I+\alpha S^{(m)}$型前処理のパラメータ$m$ \\
SAINV    & \verb=-p {sainv|6}=   & \verb=-sainv_drop [0.05]=    & ドロップ基準\\
SA-AMG   & \verb=-p {saamg|7}=   & \verb=-saamg_unsym [false]=     & 非対称版の選択 \\
         &                       &                                 & (行列構造は対称とする) \\
         &                       & \verb=-saamg_theta [0.05|0.12]= & ドロップ基準 $a^2_{ij}\le\theta^2|a_{ii}||a_{jj}|$ \\
         &                       &                             & (対称\verb=|=非対称) \\
crout ILU& \verb=-p {iluc|8}=    & \verb=-iluc_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-iluc_rate [5.0]=     & 最大フィルイン数の倍率 \\
ILUT     & \verb=-p {ilut|9}=    & \verb=-ilut_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-ilut_rate [5.0]=     & 最大フィルイン数の倍率 \\
Additive Schwarz  & \verb=-adds true=   &  \verb=-adds_iter [1]= & 繰り返し回数   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf その他のオプション}\\
\begin{tabular}{l|ll}\hline\hline
オプション &                          \\ \hline
\verb=-emaxiter [1000]= & 最大反復回数         \\ 
\verb=-etol [1.0e-12]=  & 収束判定基準              \\
\verb=-eprint [0]=      & 残差の画面表示                 \\
                       & \verb=-eprint {none|0}     =  何もしない \\
                       & \verb=-eprint {mem|1}      =  収束履歴をメモリに保存する\\
                       & \verb=-eprint {out|2}      =  収束履歴を画面に表示する\\
                       & \verb=-eprint {all|3}      =  収束履歴をメモリに保存し画面に表示する\\
\verb=-ie [ii]= & Lanczos Iteration, Subspace Iteration の内部で使用する固有値解法の指定  \\
                       & \verb=-ie {pi|1}     =  Power Iteration (Subspace Iteration のみ) \\
                       & \verb=-ie {ii|2}     =  Inverse Iteration \\
                       & \verb=-ie {aii|3}    =  Approximate Inverse Iteration \\
                       & \verb=-ie {rqi|4}    =  Rayleigh Quotient Iteration \\
\verb=-shift [0.0]= & 固有値のシフト量  \\
\verb=-initx_ones [true]= & 初期ベクトル$x_{0}$の振舞い  \\
                       & \verb=-initx_ones {false|0}     =  与えられた値を使用 \\
                       & \verb=-initx_ones {true|1}      =  すべての要素を$1$にする\\
\verb=-omp_num_threads [t]= & 実行スレッド数         \\ 
                            & \verb=t=は最大スレッド数 \\
\verb=-estorage [0]=   & 行列格納形式 \\
\verb=-estorage_block [2]= & BSR, BSCのブロックサイズ \\ 
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 演算精度の指定} デフォルト: \verb=-ef double=\\
\begin{tabular}{l|lll}\hline\hline
精度     & オプション           & 補助オプション \\ \hline
倍精度   & \verb=-ef {double|0}=    &   \\
4倍精度  & \verb=-ef {quad|1}=    &   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\ \\
\noindent
\newpage
{\bf 求解}

固有値問題$Ax=\lambda x$を解くには関数
\begin{itemize}
\item \verb|C       int lis_esolve(LIS_MATRIX A, LIS_VECTOR x,|\\
      \verb|         LIS_REAL evalue, LIS_ESOLVER esolver)|
\item \verb|Fortran subroutine lis_esolve(LIS_MATRIX A, LIS_VECTOR x,|\\
      \verb|         LIS_ESOLVER esolver, integer ierr)|
\end{itemize}
を用いる. 

\subsection{サンプルプログラム}
\label{sec:testprog3}
線型方程式系$Ax=b$を指定された解法で解き, その解を表示する
プログラムを以下に示す. 

行列$A$は次数$12$の3重対角行列
\[
A = 
\left(
\begin{array}{ccccc}
2 & -1 &   &  &   \\
-1 & 2 & -1 &  &   \\
  & \ddots  & \ddots  & \ddots  &   \\
  &   & -1 & 2 & -1 \\
  &   &   & -1 & 2 \\
\end{array}
\right)
\]
である. 右辺ベクトル$b$は解$x$がすべて$1$となるように
求めている. 

このプログラムは\verb|lis-($VERSION)/test|ディレクトリにある. 
\begin{itembox}[l]{テストプログラム: test4.c}
{\small
\begin{verbatim}
 1: #include <stdio.h> 
 2: #include "lis.h" 
 3: main(int argc, char *argv[]) 
 4: { 
 5:     int i,n,gn,is,ie,iter; 
 6:     LIS_MATRIX A; 
 7:     LIS_VECTOR b,x,u; 
 8:     LIS_SOLVER solver; 
 9:     n = 12; 
10:     lis_initialize(&argc,&argv); 
11:     lis_matrix_create(LIS_COMM_WORLD,&A); 
12:     lis_matrix_set_size(A,0,n); 
13:     lis_matrix_get_size(A,&n,&gn) 
14:     lis_matrix_get_range(A,&is,&ie) 
15:     for(i=is;i<ie;i++) 
16:     { 
17:         if( i>0 ) lis_matrix_set_value(LIS_INS_VALUE,i,i-1,-1.0,A); 
18:         if( i<gn-1 ) lis_matrix_set_value(LIS_INS_VALUE,i,i+1,-1.0,A); 
19:         lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0,A); 
20:     } 
21:     lis_matrix_set_type(A,LIS_MATRIX_CRS); 
22:     lis_matrix_assemble(A); 
23:  
24:     lis_vector_duplicate(A,&u); 
25:     lis_vector_duplicate(A,&b); 
26:     lis_vector_duplicate(A,&x); 
27:     lis_vector_set_all(1.0,u); 
28:     lis_matvec(A,u,b); 
29:  
30:     lis_solver_create(&solver); 
31:     lis_solver_set_optionC(solver); 
32:     lis_solve(A,b,x,solver); 
33:     lis_solver_get_iters(solver,&iter); 
34:     printf("iter = %d\n",iter); 
35:     lis_vector_print(x); 
36:     lis_matrix_destroy(A); 
37:     lis_vector_destroy(u); 
38:     lis_vector_destroy(b); 
39:     lis_vector_destroy(x); 
40:     lis_solver_destroy(solver); 
41:     lis_finalize(); 
42:     return 0; 
43: } 
}
\end{verbatim}
}
\end{itembox}
\begin{itembox}[l]{テストプログラム: test4f.F}
{\small
\begin{verbatim}
 1:      implicit none
 2:      
 3:#include "lisf.h"
 4:
 5:      integer          i,n,gn,is,ie,iter,ierr
 6:      LIS_MATRIX        A
 7:      LIS_VECTOR        b,x,u
 8:      LIS_SOLVER        solver
 9:      n  = 12
10:      call lis_initialize(ierr)
11:      call lis_matrix_create(LIS_COMM_WORLD,A,ierr)
12:      call lis_matrix_set_size(A,0,n,ierr)
13:      call lis_matrix_get_size(A,n,gn,ierr)
14:      call lis_matrix_get_range(A,is,ie,ierr)
15:      do i=is,ie-1
16:        if( i>1  ) call lis_matrix_set_value(LIS_INS_VALUE,i,i-1,-1.0d0,
17:     .                                        A,ierr)
18:        if( i<gn ) call lis_matrix_set_value(LIS_INS_VALUE,i,i+1,-1.0d0,
19:     .                                        A,ierr)
20:        call lis_matrix_set_value(LIS_INS_VALUE,i,i,2.0d0,A,ierr)
21:      enddo
22:      call lis_matrix_set_type(A,LIS_MATRIX_CRS,ierr)
23:      call lis_matrix_assemble(A,ierr)
24:
25:      call lis_vector_duplicate(A,u,ierr)
26:      call lis_vector_duplicate(A,b,ierr)
27:      call lis_vector_duplicate(A,x,ierr)
28:      call lis_vector_set_all(1.0d0,u,ierr)
29:      call lis_matvec(A,u,b,ierr)
30:
31:      call lis_solver_create(solver,ierr)
32:      call lis_solver_set_optionC(solver,ierr)
33:      call lis_solve(A,b,x,solver,ierr)
34:      call lis_solver_get_iters(solver,iter,ierr)
35:      write(*,*) 'iter = ',iter
36:      call lis_vector_print(x,ierr)
37:      call lis_matrix_destroy(A,ierr)
38:      call lis_vector_destroy(b,ierr)
39:      call lis_vector_destroy(x,ierr)
40:      call lis_vector_destroy(u,ierr)
41:      call lis_solver_destroy(solver,ierr)
42:      call lis_finalize(ierr)
43:
44:      stop
45:      end
\end{verbatim}
}
\end{itembox}
\newpage
\subsection{コンパイル・リンク}
{\tt test4.c}のユーザプログラムをコンパイル, リンクする方法について述べる. 
\verb|lis-($VERSION)/test|ディレクトリにあるテストプログラム
\verb|test4.c|をSGI Altix 3700上のIntel C/C++ Compiler 8.1 (icc), 
Intel Fortran Compiler 8.1 (ifort)でコンパイルする場合の例を以下に示す.  
Lisライブラリのインストール時にSA-AMG前処理を利用するよう
選択 (\verb|--enable-saamg|) した場合はFortran90のコードが
含まれるため, リンクはFortran90コンパイラで行わなければならない. 
また, MPI環境では\verb|USE_MPI|マクロを指定しなければならない. 

\begin{itembox}[l]{逐次版}
\small
{\bf コンパイル}\\
\verb+      >icc -c -I$(INSTALLDIR)/include test4.c+\\
{\bf リンク}\\
\verb+      >icc -o test4 test4.o -llis+\\
{\bf リンク(\verb|--enable-saamg|)}\\
\verb+      >ifort -nofor_main -o test4 test4.o -llis+
\end{itembox}
\begin{itembox}[l]{OpenMP版}
\small
{\bf コンパイル}\\
\verb+      >icc -c -openmp -I$(INSTALLDIR)/include test4.c+\\
{\bf リンク}\\
\verb+      >icc -openmp -o test4 test4.o -llis+\\
{\bf リンク(\verb|--enable-saamg|)}\\
\verb+      >ifort -nofor_main -openmp -o test4 test4.o -llis+
\end{itembox}
\begin{itembox}[l]{MPI版}
\small
{\bf コンパイル}\\
\verb+      >icc -c -DUSE_MPI -I$(INSTALLDIR)/include test4.c+\\
{\bf リンク}\\
\verb+      >icc -o test4 test4.o -llis -lmpi+\\
{\bf リンク(\verb|--enable-saamg|)}\\
\verb+      >ifort -nofor_main -o test4 test4.o -llis -lmpi+
\end{itembox}
\begin{itembox}[l]{OpenMP + MPI版}
\small
{\bf コンパイル}\\
\verb+      >icc -c -openmp -DUSE_MPI -I$(INSTALLDIR)/include test4.c+\\
{\bf リンク}\\
\verb+      >icc -openmp -o test4 test4.o -llis -lmpi+\\
{\bf リンク(\verb|--enable-saamg|)}\\
\verb+      >ifort -nofor_main -openmp -o test4 test4.o -llis -lmpi+
\end{itembox}
\newpage
次に, {\tt test4f.F}のユーザプログラムをコンパイル, リンクする方法について述べる. 
\verb|lis-($VERSION)/test|ディレクトリにあるテストプログラム
\verb|test4f.F|をSGI Altix 3700上の
Intel Fortran Compiler 8.1 (ifort)でコンパイルする場合の例を以下に示す. 
Fortranのユーザプログラムには\verb|#include|文が用いられているため, 
プリプロセッサを利用するようコンパイラオプションを指定しなければならない. 
ifort の場合のオプションは\verb|-fpp| である. 

\begin{itembox}[l]{逐次版}
\small
{\bf コンパイル}\\
\verb+      >ifort -c -fpp -I$(INSTALLDIR)/include test4f.F+\\
{\bf リンク}\\
\verb+      >ifort -o test4 test4.o -llis+\\
\end{itembox}
\begin{itembox}[l]{OpenMP版}
\small
{\bf コンパイル}\\
\verb+      >ifort -c -fpp -openmp -I$(INSTALLDIR)/include test4f.F+\\
{\bf リンク}\\
\verb+      >ifort -openmp -o test4 test4.o -llis+\\
\end{itembox}
\begin{itembox}[l]{MPI版}
\small
{\bf コンパイル}\\
\verb+      >ifort -c -fpp -DUSE_MPI -I$(INSTALLDIR)/include test4f.F+\\
{\bf リンク}\\
\verb+      >ifort -o test4 test4.o -llis -lmpi+\\
\end{itembox}
\begin{itembox}[l]{OpenMP + MPI版}
\small
{\bf コンパイル}\\
\verb+      >ifort -c -fpp -openmp -DUSE_MPI -I$(INSTALLDIR)/include test4f.F+\\
{\bf リンク}\\
\verb+      >ifort -openmp -o test4 test4.o -llis -lmpi+\\
\end{itembox}
\newpage
\subsection{実行}
\verb|lis-($VERSION)/test|ディレクトリにあるテストプログラム
\verb|test4| または \verb|test4f| をSGI Altix 3700上のそれぞれの環境で \\
{\bf 逐次版}\\
\verb+      >./test4 -i bicgstab+\\
{\bf OpenMP版}\\
\verb+      >env OMP_NUM_THREADS=2 ./test4 -i bicgstab +\\
{\bf MPI版}\\
\verb+      >mpirun -np 2 ./test4 -i bicgstab +\\
{\bf OpenMP + MPI版}\\
\verb+      >mpirun -np 2 env OMP_NUM_THREADS=2 ./test4 -i bicgstab +\\
と入力して実行すると, 以下のように表示される. 

\begin{verbatim}
initial vector x = 0
precision : double
solver    : BiCGSTAB 4
precon    : none
storage   : CRS
lis_solve : normal end

iter = 6
     0  1.000000e-00
     1  1.000000e+00
     2  1.000000e-00
     3  1.000000e+00
     4  1.000000e-00
     5  1.000000e+00
     6  1.000000e+00
     7  1.000000e-00
     8  1.000000e+00
     9  1.000000e-00
    10  1.000000e+00
    11  1.000000e-00
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{4倍精度演算}
反復法の計算では, 丸め誤差の影響によって収束が停滞することがある. 
本ライブラリでは, 倍精度浮動小数点数を2個用いた"double-double"\cite{dd,qd}型の
4倍精度演算により, 収束を改善することが可能である. 
double-double型演算では, 浮動小数$a$を$a = a.hi + a.lo$, 
$\frac{1}{2} \mbox{ulp}(a.hi) \geq |a.lo|$
 (上位$a.hi$と下位$a.lo$は倍精度浮動小数) 
により定義し, Dekker\cite{dekker}とKnuth\cite{Knuth}のアルゴリズムに基づいて
倍精度の四則演算の組み合わせにより4倍精度演算を実現している. 
double-double型の演算は一般にFortranの4倍精度演算より高速である\cite{Bailey:High-Precision}が, 
Fortranの表現形式\cite{intel}では仮数部が112ビットであるのに対して, 
倍精度浮動小数を2個利用しているため, 仮数部が104ビットとなり, 8ビット
少ない. また, 指数部は倍精度浮動小数と同じ11ビットである. 

本ライブラリでは, 入力として与えられる行列, ベクトル, 
及び出力の解は倍精度としている. 
ユーザプログラムは4倍精度変数を直接扱うことはなく, 
オプションとして4倍精度演算を利用するかどうかを指定をするだけでよい. 
なお, Intel系のアーキテクチャに対してはStreaming SIMD Extensions (SSE)命
令, IBM系のアーキテクチャに対してはFused Multiply-Add (FMA)命令を用いて
高速化を行っている\cite{quadlis}. 

\begin{figure}[htp]
{\centering 
\includegraphics{double-double.eps}
\caption{double-double精度のビット数}
\label{fig:residual}
  }
\end{figure}


\subsection{4倍精度演算の利用}
\label{sec:testprog4}
Toepliz行列
\[
A = \left(
\begin{array}{cccccc}
2 & 1 &   &  &  & \\
0 & 2 & 1 &  &  & \\
\gamma & 0& 2 & 1 &  & \\
 & \ddots & \ddots & \ddots & \ddots & \\
 &  &   \gamma &0 &       2   & 1 \\
 &  &  &   \gamma & 0& 2 \\
\end{array}
\right)
\]
に対する線型方程式系$Ax=b$を指定された解法で解き, 解を表示する
テストプログラムが\verb|test5.c|である. 
右辺ベクトル$b$は解$x$がすべて$1$となるように
求めている. $n$は行列$A$の次数である. 
\verb|test5|において, 
\newpage
{\bf 倍精度の場合}\\
\verb+      >./test5 200 2.0 -f double+ \\
または \\
\verb+      >./test5 200 2.0+ \\
と入力して実行すると, 以下の結果が得られる. 

\begin{verbatim}
n = 200, gamma = 2.000000
initial vector x = 0
precision : double
solver    : BiCG 2
precon    : none
storage   : CRS
lis_solve : LIS_MAXITER(code=4)

BiCG: number of iterations     = 1001 (double = 1001, quad = 0)
BiCG: elapsed time             = 2.044368e-02 sec.
BiCG:   preconditioner         = 4.768372e-06 sec.
BiCG:     matrix creation      = 4.768372e-06 sec.
BiCG:   linear solver          = 2.043891e-02 sec.
BiCG: relative residual 2-norm = 8.917591e+01
\end{verbatim}

{\bf 4倍精度の場合}\\
\verb+      >./test5 200 2.0 -f quad+\\
と入力して実行すると, 以下の結果が得られる. 

\begin{verbatim}
n = 200, gamma = 2.000000
initial vector x = 0
precision : quad
solver    : BiCG 2
precon    : none
storage   : CRS
lis_solve : normal end

BiCG: number of iterations     = 230 (double = 230, quad = 0)
BiCG: elapsed time             = 2.267408e-02 sec.
BiCG:   preconditioner         = 4.549026e-04 sec.
BiCG:     matrix creation      = 5.006790e-06 sec.
BiCG:   linear solver          = 2.221918e-02 sec.
BiCG: relative residual 2-norm = 6.499145e-11
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{行列格納形式}
\label{sec:storages}
本節では, ライブラリで使用できる行列の格納形式について述べる. 
行列の行(列)番号は0から始まるものとする. 
$n \times n$行列$A=(a_{ij})$の非零要素数を$nnz$とする. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compressed Row Storage (CRS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compressed Row Storage (CRS)}
CRS形式は3つの配列({\ttfamily ptr,index,value})に格納する. 
\begin{itemize}
\item 長さ$nnz$の倍精度配列{\ttfamily value}は行列$A$の非零要素の値を行方向に沿って格納する. 
\item 長さ$nnz$の整数配列{\ttfamily index}は配列{\ttfamily value}に格納された非零要素の列番号を格納する. 
\item 長さ$n+1$の整数配列{\ttfamily ptr}は配列{\ttfamily value}と{\ttfamily index}の各行の開始位置を格納する. 
\end{itemize}

\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のCRS形式での格納方法を図\ref{fig:storage01}に示す. 
この行列をCRS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ \label{eq:mata}
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage01.eps} 
\end{flushleft}
\end{minipage}
\caption{CRS形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage01}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8;
 6: ptr   = (int *)malloc( (n+1)*sizeof(int) );
 7: index = (int *)malloc( nnz*sizeof(int) );
 8: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
 9: lis_matrix_create(0,&A);
10: lis_matrix_set_size(A,0,n);
11:
12: ptr[0] = 0; ptr[1] = 1; ptr[2] = 3; ptr[3] = 5; ptr[4] = 8;
13: index[0] =  0; index[1] =  0; index[2] =  1; index[3] =  1;
14: index[4] =  2; index[5] =  0; index[6] =  2; index[7] =  3;
15: value[0] = 11; value[1] = 21; value[2] = 22; value[3] = 32;
16: value[4] = 33; value[5] = 41; value[6] = 43; value[7] = 44;
17:
18:  lis_matrix_set_crs(nnz,ptr,index,value,A);
19:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のCRS形式での格納方法を図\ref{fig:storage01_mpi}に示す. 
2プロセス上にこの行列をCRS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage01_mpi.eps} 
\caption{CRS形式のデータ構造 (MPI版)}\label{fig:storage01_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,k,n,nnz,my_rank;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 3;}
 7: else             {n = 2; nnz = 5;}
 8: ptr   = (int *)malloc( (n+1)*sizeof(int) );
 9: index = (int *)malloc( nnz*sizeof(int) );
10: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
11: lis_matrix_create(MPI_COMM_WORLD,&A);
12: lis_matrix_set_size(A,n,0);
13: if( my_rank==0 ) {
14:     ptr[0] = 0; ptr[1] = 1; ptr[2] = 3;
15:     index[0] =  0; index[1] =  0; index[2] =  1;
16:     value[0] = 11; value[1] = 21; value[2] = 22;}
17: else {
18:     ptr[0] = 0; ptr[1] = 2; ptr[2] = 5;
19:     index[0] =  1; index[1] =  2; index[2] =  0; index[3] =  2; index[4] =  3;
20:     value[0] = 32; value[1] = 33; value[2] = 41; value[3] = 43; value[4] = 44;}
21:  lis_matrix_set_crs(nnz,ptr,index,value,A);
22:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

CRS形式に必要な配列を行列$A$に関連付けるには関数

\begin{itemize}
\item \verb|C       int lis_matrix_set_crs(int nnz, int row[], int index[], LIS_SCALAR value[],|\\
      \verb| LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_crs(integer nnz, integer row(), integer index(),|\\
      \verb| LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}

を用いる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compressed Column Storage (CCS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Compressed Column Storage (CCS)}
CCS形式は3つの配列({\ttfamily ptr,index,value})に格納する. 
\begin{itemize}
\item 長さ$nnz$の倍精度配列{\ttfamily value}は行列$A$の非零要素の値を列方向に沿って格納する. 
\item 長さ$nnz$の整数配列{\ttfamily index}は配列{\ttfamily value}に格納された非零要素の行番号を格納する. 
\item 長さ$n+1$の整数配列{\ttfamily ptr}は配列{\ttfamily value}と{\ttfamily index}の各列の開始位置を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のCCS形式での格納方法を図\ref{fig:storage02}に示す. 
この行列をCCS形式で作成する場合, プログラムは以下のように記述する. 

\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage02.eps} 
\end{flushleft}
\end{minipage}
\caption{CCS形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage02}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8;
 6: ptr   = (int *)malloc( (n+1)*sizeof(int) );
 7: index = (int *)malloc( nnz*sizeof(int) );
 8: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
 9: lis_matrix_create(0,&A);
10: lis_matrix_set_size(A,0,n);
11:
12: ptr[0] = 0; ptr[1] = 3; ptr[2] = 5; ptr[3] = 7; ptr[4] = 8;
13: index[0] =  0; index[1] =  1; index[2] =  3; index[3] =  1;
14: index[4] =  2; index[5] =  2; index[6] =  3; index[7] =  3;
15: value[0] = 11; value[1] = 21; value[2] = 41; value[3] = 22;
16: value[4] = 32; value[5] = 33; value[6] = 43; value[7] = 44;
17:
18:  lis_matrix_set_ccs(nnz,ptr,index,value,A);
19:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のCCS形式での格納方法を図\ref{fig:storage02_mpi}に
示す. 
2プロセス上にこの行列をCCS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage02_mpi.eps} 
\caption{CCS形式のデータ構造 (MPI版)}\label{fig:storage02_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,k,n,nnz,my_rank;
 2: int           *ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 3;}
 7: else             {n = 2; nnz = 5;}
 8: ptr   = (int *)malloc( (n+1)*sizeof(int) );
 9: index = (int *)malloc( nnz*sizeof(int) );
10: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
11: lis_matrix_create(MPI_COMM_WORLD,&A);
12: lis_matrix_set_size(A,n,0);
13: if( my_rank==0 ) {
14:     ptr[0] = 0; ptr[1] = 3; ptr[2] = 5;
15:     index[0] =  0; index[1] =  1; index[2] =  3; index[3] =  1; index[4] =  2;
16:     value[0] = 11; value[1] = 21; value[2] = 41; value[3] = 22; value[4] = 32}
17: else {
18:     ptr[0] = 0; ptr[1] = 2; ptr[2] = 3;
19:     index[0] =  2; index[1] =  3; index[2] =  3;
20:     value[0] = 33; value[1] = 43; value[2] = 44;}
21:  lis_matrix_set_ccs(nnz,ptr,index,value,A);
22:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

CCS形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_ccs(int nnz, int row[], int index[], LIS_SCALAR value[],|\\
      \verb| LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_ccs(integer nnz, integer row(), integer index(),|\\
      \verb| LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modified Compressed Sparse Row (MSR)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Modified Compressed Sparse Row (MSR)}
MSR形式はCRS形式を修正したものである. その違いは対角部分を分けて格納しているところである. 
MSR形式は2つの配列({\ttfamily index,value})に格納する. $ndz$を対角部分の零要素数とする. 
\begin{itemize}
\item 長さ$nnz + ndz + 1$の倍精度配列{\ttfamily value}は
$n$番目までは行列$A$の対角部分を格納する. $n+1$番目の要素は使用しない. $n+2$番目からは
行列$A$の対角以外の非零要素の値を行方向に沿って格納する. 
\item 長さ$nnz + ndz + 1$の整数配列{\ttfamily index}は
$n+1$番目までは行列$A$の非対角部分の各行の開始位置を格納する. 
$n+2$番目からは行列$A$の非対角部分の配列{\ttfamily value}に格納された非零要素の列番号を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のMSR形式での格納方法を図\ref{fig:storage03}に示す. 
この行列をMSR形式で作成する場合, プログラムは以下のように記述する. 

\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage03.eps} 
\end{flushleft}
\end{minipage}
\caption{MSR形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage03}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz,ndz;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8; ndz = 0;
 6: index = (int *)malloc( (nnz+ndz+1)*sizeof(int) );
 7: value = (LIS_SCALAR *)malloc( (nnz+ndz+1)*sizeof(LIS_SCALAR) );
 8: lis_matrix_create(0,&A);
 9: lis_matrix_set_size(A,0,n);
10:
11: index[0] =  5; index[1] =  5; index[2] =  6; index[3] =  7;
12: index[4] =  9; index[5] =  0; index[6] =  1; index[7] =  0; index[8] =  2;
13: value[0] = 11; value[1] = 22; value[2] = 33; value[3] = 44;
14: value[4] =  0; value[5] = 21; value[6] = 32; value[7] = 41; value[8] = 43;
15:
16:  lis_matrix_set_msr(nnz,ndz,index,value,A);
17:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のMSR形式での格納方法を図\ref{fig:storage03_mpi}に
示す. 
2プロセス上にこの行列をMSR形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage03_mpi.eps} 
\caption{MSR形式のデータ構造 (MPI版)}\label{fig:storage03_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,k,n,nnz,ndz,my_rank;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 3; ndz = 0;}
 7: else             {n = 2; nnz = 5; ndz = 0;}
 8: index = (int *)malloc( (nnz+ndz+1)*sizeof(int) );
 9: value = (LIS_SCALAR *)malloc( (nnz+ndz+1)*sizeof(LIS_SCALAR) );
10: lis_matrix_create(MPI_COMM_WORLD,&A);
11: lis_matrix_set_size(A,n,0);
12: if( my_rank==0 ) {
13:     index[0] =  3; index[1] =  3; index[2] =  4; index[3] =  0;
14:     value[0] = 11; value[1] = 22; value[2] =  0; value[3] = 21;}
15: else {
16:     index[0] =  3; index[1] =  4; index[2] =  6; index[3] =  1;
17:     index[4] =  0; index[5] =  2;
18:     value[0] = 33; value[1] = 44; value[2] =  0; value[3] = 32;
19:     value[4] = 41; value[5] = 43;}
20:  lis_matrix_set_msr(nnz,ndz,index,value,A);
21:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

MSR形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_msr(int nnz, int ndz, int index[], LIS_SCALAR value[], |\\
      \verb|LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_msr(integer nnz, integer ndz, integer index(),|\\
      \verb| LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diagonal (DIA)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Diagonal (DIA)}
DIAは2つの配列({\ttfamily index, value})に格納する. 
$nnd$を行列$A$の非零な対角要素の本数とする. 
\begin{itemize}
\item 長さ$nnd \times n$の倍精度配列{\ttfamily value}は行列$A$の非零な対
      角要素を格納する. 
\item 長さ$nnd$の整数配列{\ttfamily index}は主対角要素から各対角要素へのオフセットを格納する. 
\end{itemize}
OpenMP版では以下のように修正している. \\
DIAは2つの配列({\ttfamily index, value})に格納する. $nprocs$をスレッド数とする. 
$nnd_p$を行列$A$を行ブロック分割した部分行列の非零な対角の本数とする. 
$maxnnd$を$nnd_p$の値の最大値とする. 
\begin{itemize}
\item 長さ$maxnnd \times n$の倍精度配列{\ttfamily value}は行列$A$を行ブ
      ロック分割した部分行列の非零な対角要素を格納する. 
\item 長さ$nprocs \times maxnnd$の整数配列{\ttfamily index}は主対角要素から各対角要素へのオフセットを格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次版)}
行列$A$のDIA形式での格納方法を図\ref{fig:storage04}に示す. 
この行列をDIA形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage04.eps} 
\end{flushleft}
\end{minipage}
\caption{DIA形式のデータ構造 (逐次版)}\label{fig:storage04}}
\end{figure}
\begin{itembox}[l]{逐次版}
\small
\begin{verbatim}
 1: int           n,nnd;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnd = 3;
 6: index = (int *)malloc( nnd*sizeof(int) );
 7: value = (LIS_SCALAR *)malloc( n*nnd*sizeof(LIS_SCALAR) );
 8: lis_matrix_create(0,&A);
 9: lis_matrix_set_size(A,0,n);
10:
11: index[0] = -3; index[1] = -1; index[2] =  0;
12: value[0] =  0; value[1] =  0; value[2] =  0; value[3] = 41;
13: value[4] =  0; value[5] = 21; value[6] = 32; value[7] = 43;
14: value[8] = 11; value[9] = 22; value[10]= 33; value[11]= 44;
15:
16:  lis_matrix_set_dia(nnd,index,value,A);
17:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{行列の作り方 (OpenMP版)}
2スレッド上への行列$A$のDIA形式での格納方法を図\ref{fig:storage04_omp}に
示す. 
2スレッド上にこの行列をDIA形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage04_omp.eps} 
\caption{DIA形式のデータ構造 (OpenMP版)}\label{fig:storage04_omp}}
\end{figure}
\begin{itembox}[l]{OpenMP版}
\small
\begin{verbatim}
 1: int           n,maxnnd,nprocs;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; maxnnd = 3; nprocs = 2;
 6: index = (int *)malloc( maxnnd*sizeof(int) );
 7: value = (LIS_SCALAR *)malloc( n*maxnnd*sizeof(LIS_SCALAR) );
 8: lis_matrix_create(0,&A);
 9: lis_matrix_set_size(A,0,n);
10:
11: index[0] = -1; index[1] =  0; index[2] =  0; index[3] = -3; index[4] = -1; index[5] =  0;
12: value[0] =  0; value[1] = 21; value[2] = 11; value[3] = 22; value[4] =  0; value[5] =  0;
13: value[6] =  0; value[7] = 41; value[8] = 32; value[9] = 43; value[10]= 33; value[11]= 44;
14:
15:  lis_matrix_set_dia(maxnnd,index,value,A);
16:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のDIA形式での格納方法を図\ref{fig:storage04_mpi}に
示す. 
2プロセス上にこの行列をDIA形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage04_mpi.eps} 
\caption{DIA形式のデータ構造 (MPI版)}\label{fig:storage04_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,n,nnd,my_rank;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnd = 2;}
 7: else             {n = 2; nnd = 3;}
 8: index = (int *)malloc( nnd*sizeof(int) );
 9: value = (LIS_SCALAR *)malloc( n*nnd*sizeof(LIS_SCALAR) );
10: lis_matrix_create(MPI_COMM_WORLD,&A);
11: lis_matrix_set_size(A,n,0);
12: if( my_rank==0 ) {
13:     index[0] = -1; index[1] =  0;
14:     value[0] =  0; value[1] = 21; value[2] = 11; value[3] = 22;}
15: else {
16:     index[0] = -3; index[1] = -1; index[2] =  0;
17:     value[0] =  0; value[1] = 41; value[2] = 32; value[3] = 43; value[4] = 33;
18:     value[5] = 44;}
19:  lis_matrix_set_dia(nnd,index,value,A);
20:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

DIA形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_dia(int nnd, int index[], LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_dia(integer nnd, integer index(), LIS_SCALAR value(),|\\
      \verb| LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ellpack-Itpack generalized diagonal (ELL)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Ellpack-Itpack generalized diagonal (ELL)}
ELLは2つの配列({\ttfamily index, value})に格納する. 
$maxnzr$を行列$A$の各行での非零要素数の最大値とする. 
\begin{itemize}
\item 長さ$maxnzr \times n$の倍精度配列{\ttfamily value}は行列$A$の各行の非零要素を列方向に沿って格納する. 
最初の列は各行の最初の非零要素からなる. ただし, 格納する非零要素がない場合は$0$を格納する. 
\item 長さ$maxnzr \times n$の整数配列{\ttfamily index}は
配列{\ttfamily value}に格納された非零要素の列番号を格納する. 
ただし, 第$i$行目の非零要素数を$nnz$とすると{\tt index[$nnz \times + i$]}にはその行番号$i$を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のELL形式での格納方法を図\ref{fig:storage05}に示す. 
この行列をELL形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage05.eps} 
\end{flushleft}
\end{minipage}
\caption{ELL形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage05}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,maxnzr;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; maxnzr = 3;
 6: index = (int *)malloc( n*maxnzr*sizeof(int) );
 7: value = (LIS_SCALAR *)malloc( n*maxnzr*sizeof(LIS_SCALAR) );
 8: lis_matrix_create(0,&A);
 9: lis_matrix_set_size(A,0,n);
10:
11: index[0] =  0; index[1] =  0; index[2] =  1; index[3] =  0; index[4] =  0; index[5] =  1;
12: index[6] =  2; index[7] =  2; index[8] =  0; index[9] =  1; index[10]=  2; index[11]=  3;
13: value[0] = 11; value[1] = 21; value[2] = 32; value[3] = 41; value[4] =  0; value[5] = 22;
14: value[6] = 33; value[7] = 43; value[8] =  0; value[9] =  0; value[10]=  0; value[11]= 44;
15:
16:  lis_matrix_set_ell(maxnzr,index,value,A);
17:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のELL形式での格納方法を図\ref{fig:storage05_mpi}に
示す. 
2プロセス上にこの行列をELL形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage05_mpi.eps} 
\caption{ELL形式のデータ構造 (MPI版)}\label{fig:storage05_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,n,maxnzr,my_rank;
 2: int           *index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; maxnzr = 2;}
 7: else             {n = 2; maxnzr = 3;}
 8: index = (int *)malloc( n*maxnzr*sizeof(int) );
 9: value = (LIS_SCALAR *)malloc( n*maxnzr*sizeof(LIS_SCALAR) );
10: lis_matrix_create(MPI_COMM_WORLD,&A);
11: lis_matrix_set_size(A,n,0);
12: if( my_rank==0 ) {
13:     index[0] =  0; index[1] =  0; index[2] =  0; index[3] =  1;
14:     value[0] = 11; value[1] = 21; value[2] =  0; value[3] = 22;}
15: else {
16:     index[0] =  1; index[1] =  0; index[2] =  2; index[3] =  2; index[4] =  2;
17:     index[5] =  3;
18:     value[0] = 32; value[1] = 41; value[2] = 33; value[3] = 43; value[4] =  0;
19:     value[5] = 44;}
20:  lis_matrix_set_ell(maxnzr,index,value,A);
21:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

ELL形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_ell(int maxnzr, int index[], LIS_SCALAR value[],|\\
      \verb| LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_ell(integer maxnzr, integer index(),|\\
      \verb| LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jagged Diagonal (JDS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Jagged Diagonal (JDS)}
JDSは最初に各行の非零要素数の大きい順に行の並び替えを行い, 
各行の非零要素を列方向に沿って格納する. 
JDSは4つの配列({\ttfamily perm, ptr, index, value})に格納する. 
$maxnzr$を行列$A$の各行での非零要素数の最大値とする. 
\begin{itemize}
\item 長さ$n$の整数配列{\ttfamily perm}は並び替えた行番号を格納する. 
\item 長さ$nnz$の倍精度配列{\ttfamily value}は並び替えられた行列$A$の鋸
      歯状対角要素を格納する. 
最初の鋸歯状対角要素は各行の最初の非零要素からなる. 
次の鋸歯状対角要素は各行の２番目の非零要素からなる. これを順次繰り返していく. 
\item 長さ$nnz$の整数配列{\ttfamily index}は配列{\ttfamily value}に格納された非零要素の列番号を格納する. 
\item 長さ$maxnzr + 1$の整数配列{\ttfamily ptr}は各鋸歯状対角要素の開始位置を格納する. 
\end{itemize}
OpenMP版では以下のように修正を行っている. \\
JDSは4つの配列({\ttfamily perm, ptr, index, value})に格納する. 
$nprocs$をスレッド数とする. 
$maxnzr_p$を行列$A$を行ブロック分割した部分行列の各行での非零要素数の最大値とする. 
$maxmaxnzr$は配列$maxnzr_p$の値の最大値である. 
\begin{itemize}
\item 長さ$n$の整数配列{\ttfamily perm}は行列$A$を行ブロック分割した部分行列を並び替えた行番号を格納する. 
\item 長さ$nnz$の倍精度配列{\ttfamily value}は並び替えられた行列$A$の鋸
      歯状対角要素を格納する. 
最初の鋸歯状対角要素は各行の最初の非零要素からなる. 
次の鋸歯状対角要素は各行の２番目の非零要素からなる. これを順次繰り返していく. 
\item 長さ$nnz$の整数配列{\ttfamily index}は配列{\ttfamily value}に格納された非零要素の列番号を格納する. 
\item 長さ$nprocs \times (maxmaxnzr + 1)$の整数配列{\ttfamily ptr}は行列
      $A$を行ブロック分割した部分行列の各鋸歯状対角要素の開始位置を格納する. 
\end{itemize}
\newpage
\subsubsection{行列の作り方 (逐次版)}
行列$A$のJDS形式での格納方法を図\ref{fig:storage06}に示す. 
この行列をJDS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage06.eps} 
\end{flushleft}
\end{minipage}
\caption{JDS形式のデータ構造 (逐次版)}\label{fig:storage06}}
\end{figure}
\begin{itembox}[l]{逐次版}
\small
\begin{verbatim}
 1: int           n,nnz,maxnzr;
 2: int           *perm,*ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8; maxnzr = 3;
 6: perm  = (int *)malloc( n*sizeof(int) );
 7: ptr   = (int *)malloc( (maxnzr+1)*sizeof(int) );
 8: index = (int *)malloc( nnz*sizeof(int) );
 9: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
10: lis_matrix_create(0,&A);
11: lis_matrix_set_size(A,0,n);
12:
13: perm[0] = 3; perm[1] = 1; perm[2] = 2; perm[3] = 0;
14: ptr[0]  = 0; ptr[1]  = 4; ptr[2]  = 7; ptr[3]  = 8;
15: index[0] =  0; index[1] =  0; index[2] =  1; index[3] =  0;
16: index[4] =  2; index[5] =  1; index[6] =  2; index[7] =  3;
17: value[0] = 41; value[1] = 21; value[2] = 32; value[3] = 11;
18: value[4] = 43; value[5] = 22; value[6] = 33; value[7] = 44;
19:
20:  lis_matrix_set_jds(nnz,maxnzr,perm,ptr,index,value,A);
21:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (OpenMP版)}
2スレッド上への行列$A$のJDS形式での格納方法を図\ref{fig:storage06_omp}に
示す. 
2スレッド上にこの行列をJDS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage06_omp.eps} 
\caption{JDS形式のデータ構造 (OpenMP版)}\label{fig:storage06_omp}}
\end{figure}
\begin{itembox}[l]{OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz,maxmaxnzr,nprocs;
 2: int           *perm,*ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8; maxmaxnzr = 3; nprocs = 2;
 6: perm  = (int *)malloc( n*sizeof(int) );
 7: ptr   = (int *)malloc( nprocs*(maxmaxnzr+1)*sizeof(int) );
 8: index = (int *)malloc( nnz*sizeof(int) );
 9: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
10: lis_matrix_create(0,&A);
11: lis_matrix_set_size(A,0,n);
12:
13: perm[0] = 1; perm[1] = 0; perm[2] = 3; perm[3] = 2;
14: ptr[0]  = 0; ptr[1]  = 2; ptr[2]  = 3; ptr[3]  = 0;
15: ptr[4]  = 3; ptr[5]  = 5; ptr[6]  = 7; ptr[7]  = 8;
16: index[0] =  0; index[1] =  0; index[2] =  1; index[3] =  0;
17: index[4] =  1; index[5] =  2; index[6] =  2; index[7] =  3;
18: value[0] = 21; value[1] = 11; value[2] = 22; value[3] = 41;
19: value[4] = 32; value[5] = 43; value[6] = 33; value[7] = 44;
20:
21:  lis_matrix_set_jds(nnz,maxmaxnzr,perm,ptr,index,value,A);
22:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のJDS形式での格納方法を図\ref{fig:storage06_mpi}に
示す. 
2プロセス上にこの行列をJDS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage06_mpi.eps} 
\caption{JDS形式のデータ構造 (MPI版)}\label{fig:storage06_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           i,n,nnz,maxnzr,my_rank;
 2: int           *perm,*ptr,*index;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 3; maxnzr = 2;}
 7: else             {n = 2; nnz = 5; maxnzr = 3;}
 8: perm  = (int *)malloc( n*sizeof(int) );
 9: ptr   = (int *)malloc( (maxnzr+1)*sizeof(int) );
10: index = (int *)malloc( nnz*sizeof(int) );
11: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
12: lis_matrix_create(MPI_COMM_WORLD,&A);
13: lis_matrix_set_size(A,n,0);
14: if( my_rank==0 ) {
15:     perm[0] = 1; perm[1] = 0;
16:     ptr[0]  = 0; ptr[1]  = 2; ptr[2]  = 3;
17:     index[0] =  0; index[1] =  0; index[2] =  1;
18:     value[0] = 21; value[1] = 11; value[2] = 22;}
19: else {
20:     perm[0] = 3; perm[1] = 2;
21:     ptr[0]  = 0; ptr[1]  = 2; ptr[2]  = 4; ptr[3]  = 5;
22:     index[0] =  0; index[1] =  1; index[2] =  2; index[3] =  2; index[4] =  3;
23:     value[0] = 41; value[1] = 32; value[2] = 43; value[3] = 33; value[4] = 44;}
24:  lis_matrix_set_jds(nnz,maxnzr,perm,ptr,index,value,A);
25:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

JDS形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_jds(int nnz, int maxnzr, int perm[], int ptr[],|\\
      \verb| int index[], LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_jds(integer nnz, integer maxnzr, integer ptr(),|\\
      \verb| integer index(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Block Sparse Row (BSR)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Sparse Row (BSR)}
BSRでは行列を$r \times c$の大きさの部分行列 (ブロックと呼ぶ) に分解する. 
BSRはCRSと同様の手順で非零ブロック (少なくとも1つの
非零要素が存在する) を格納する. 
$nr=n/r$, $nnzb$を$A$の非零ブロック数とする. 
BSRは3つの配列({\ttfamily bptr, bindex, value})に格納する. 
\begin{itemize}
\item 長さ$nnzb \times r \times c$の倍精度配列{\ttfamily value}は非零ブロックの全要素を格納する. 
\item 長さ$nnzb$の整数配列{\ttfamily bindex}は非零ブロックのブロック列番号を格納する. 
\item 長さ$nr+1$の整数配列{\ttfamily bptr}は配列{\ttfamily bindex}のブロック行の開始位置を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のBSR形式での格納方法を図\ref{fig:storage07}に示す. 
この行列をBSR形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cc|cc}
11 &    &    &    \\
21 & 22 &    &    \\ \hline
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage07.eps} 
\end{flushleft}
\end{minipage}
\caption{BSR形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage07}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,bnr,bnc,nr,nc,bnnz;
 2: int           *bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; bnr = 2; bnc = 2; bnnz = 3; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;
 6: bptr   = (int *)malloc( (nr+1)*sizeof(int) );
 7: bindex = (int *)malloc( bnnz*sizeof(int) );
 8: value  = (LIS_SCALAR *)malloc( bnr*bnc*bnnz*sizeof(LIS_SCALAR) );
 9: lis_matrix_create(0,&A);
10: lis_matrix_set_size(A,0,n);
11:
12: bptr[0] = 0; bptr[1] = 1; bptr[2] = 3;
13: bindex[0] =  0; bindex[1] =  0; bindex[2] =  1;
14: value[0]  = 11; value[1] = 21; value[2] =  0; value[3] = 22;
15: value[4]  =  0; value[5] = 41; value[6] = 32; value[7] =  0;
16: value[8]  = 33; value[9] = 43; value[10]=  0; value[11]= 44;
17:
18:  lis_matrix_set_bsr(bnr,bnc,bnnz,bptr,bindex,value,A);
19:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のBSR形式での格納方法を図\ref{fig:storage07_mpi}に
示す. 
2プロセス上にこの行列をBSR形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage07_mpi.eps} 
\caption{BSR形式のデータ構造 (MPI版)}\label{fig:storage07_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           n,bnr,bnc,nr,nc,bnnz,my_rank;
 2: int           *bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; bnr = 2; bnc = 2; bnnz = 1; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;}
 7: else             {n = 2; bnr = 2; bnc = 2; bnnz = 2; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;}
 8: bptr   = (int *)malloc( (nr+1)*sizeof(int) );
 9: bindex = (int *)malloc( bnnz*sizeof(int) );
10: value  = (LIS_SCALAR *)malloc( bnr*bnc*bnnz*sizeof(LIS_SCALAR) );
11: lis_matrix_create(MPI_COMM_WORLD,&A);
12: lis_matrix_set_size(A,n,0);
13: if( my_rank==0 ) {
14:     bptr[0] = 0; bptr[1] = 1;
15:     bindex[0] =  0;
16:     value[0]  = 11; value[1] = 21; value[2] =  0; value[3] = 22;}
17: else {
18:     bptr[0] = 0; bptr[1] = 2;
19:     bindex[0] =  0; bindex[1] =  1;
20:     value[0]  =  0; value[1]  = 41; value[2] = 32; value[3] =  0;
21:     value[4]  = 33; value[5]  = 43; value[6] =  0; value[7] = 44;}
22:  lis_matrix_set_bsr(bnr,bnc,bnnz,bptr,bindex,value,A);
23:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

BSR形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_bsr(int bnr, int bnc, int bnnz, int bptr[],|\\
      \verb| int bindex[], LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_bsr(integer bnr, integer bnc, integer bnnz,|\\
      \verb| integer bptr(), integer bindex(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Block Sparse Column (BSC)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Sparse Column (BSC)}
BSCでは行列を$r \times c$の大きさの部分行列 (ブロックと呼ぶ) に分解する. 
BSCはCCSと同様の手順で非零ブロック (少なくとも1つの
非零要素が存在する) を格納する. 
$nc=n/c$, $nnzb$を$A$の非零ブロック数とする. 
BSCは3つの配列({\ttfamily bptr, bindex, value})に格納する. 
\begin{itemize}
\item 長さ$nnzb \times r \times c$の倍精度配列{\ttfamily value}は非零ブロックの全要素を格納する. 
\item 長さ$nnzb$の整数配列{\ttfamily bindex}は非零ブロックのブロック行番号を格納する. 
\item 長さ$nc+1$の整数配列{\ttfamily bptr}は配列{\ttfamily bindex}のブロック列の開始位置を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のBSC形式での格納方法を図\ref{fig:storage08}に示す. 
この行列をBSC形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cc|cc}
11 &    &    &    \\
21 & 22 &    &    \\ \hline
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage08.eps} 
\end{flushleft}
\end{minipage}
\caption{BSC形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage08}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,bnr,bnc,nr,nc,bnnz;
 2: int           *bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; bnr = 2; bnc = 2; bnnz = 3; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;
 6: bptr   = (int *)malloc( (nc+1)*sizeof(int) );
 7: bindex = (int *)malloc( bnnz*sizeof(int) );
 8: value  = (LIS_SCALAR *)malloc( bnr*bnc*bnnz*sizeof(LIS_SCALAR) );
 9: lis_matrix_create(0,&A);
10: lis_matrix_set_size(A,0,n);
11:
12: bptr[0] = 0; bptr[1] = 1; bptr[2] = 3;
13: bindex[0] =  0; bindex[1] =  1; bindex[2] =  1;
14: value[0]  = 11; value[1] = 21; value[2] =  0; value[3] = 22;
15: value[4]  =  0; value[5] = 41; value[6] = 32; value[7] =  0;
16: value[8]  = 33; value[9] = 43; value[10]=  0; value[11]= 44;
17:
18:  lis_matrix_set_bsc(bnr,bnc,bnnz,bptr,bindex,value,A);
19:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のBSC形式での格納方法を図\ref{fig:storage08_mpi}に
示す. 
2プロセス上にこの行列をBSC形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage08_mpi.eps} 
\caption{BSC形式のデータ構造 (MPI版)}\label{fig:storage08_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           n,bnr,bnc,nr,nc,bnnz,my_rank;
 2: int           *bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; bnr = 2; bnc = 2; bnnz = 2; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;}
 7: else             {n = 2; bnr = 2; bnc = 2; bnnz = 1; nr = (n-1)/bnr+1; nc = (n-1)/bnc+1;}
 8: bptr   = (int *)malloc( (nr+1)*sizeof(int) );
 9: bindex = (int *)malloc( bnnz*sizeof(int) );
10: value  = (LIS_SCALAR *)malloc( bnr*bnc*bnnz*sizeof(LIS_SCALAR) );
11: lis_matrix_create(MPI_COMM_WORLD,&A);
12: lis_matrix_set_size(A,n,0);
13: if( my_rank==0 ) {
14:     bptr[0] = 0; bptr[1] = 2;
15:     bindex[0] =  0; bindex[1] =  1;
16:     value[0]  = 11; value[1]  = 21; value[2] =  0; value[3] = 22;
17:     value[4]  =  0; value[5]  = 41; value[6] = 32; value[7] =  0;}
18: else {
19:     bptr[0] = 0; bptr[1] = 1;
20:     bindex[0] =  1;
21:     value[0]  = 33; value[1]  = 43; value[2] =  0; value[3] = 44;}
22:  lis_matrix_set_bsc(bnr,bnc,bnnz,bptr,bindex,value,A);
23:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

BSC形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_bsc(int bnr, int bnc, int bnnz, int bptr[],|\\
      \verb| int bindex[], LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_bsc(integer bnr, integer bnc, integer bnnz,|\\
      \verb| integer bptr(), integer bindex(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Variable Block Row (VBR)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Variable Block Row (VBR)}
VBR形式はBSR形式を一般化したものである. 
行と列の分割位置は配列({\ttfamily row, col})で与えられる. 
VBRはCRSと同様の手順で非零ブロック (少なくとも1つの
非零要素が存在する) を格納する. 
$nr$, $nc$をそれぞれ行分割数, 列分割数とする. 
$nnzb$を$A$の非零ブロック数, $nnz$を非零ブロックの全要素数とする. 
VBRは6つの配列({\ttfamily bptr, bindex, row, col, ptr, value})に格納する. 
\begin{itemize}
\item 長さ$nr+1$の整数配列{\ttfamily row}はブロック行の開始行番号を格納する. 
\item 長さ$nc+1$の整数配列{\ttfamily col}はブロック列の開始列番号を格納する. 
\item 長さ$nnzb$の整数配列{\ttfamily bindex}は非零ブロックのブロック列番号を格納する. 
\item 長さ$nr+1$の整数配列{\ttfamily bptr}は配列{\ttfamily bindex}のブロック行の開始位置を格納する. 
\item 長さ$nnz$の倍精度配列{\ttfamily value}は非零ブロックの全要素を格納する. 
\item 長さ$nnzb+1$の整数配列{\ttfamily ptr}は配列{\ttfamily value}の非零ブロックの開始位置を格納する. 
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のVBR形式での格納方法を図\ref{fig:storage09}に示す. 
この行列をVBR形式で作成する場合, プログラムは以下のように記述する. 
\end{itemize}
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{c|cc|c}
11 &    &    &    \\ \hline
21 & 22 &    &    \\
   & 32 & 33 &    \\ \hline
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage09.eps} 
\end{flushleft}
\end{minipage}
\caption{VBR形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage09}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz,nr,nc,bnnz;
 2: int           *row,*col,*ptr,*bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 11; bnnz = 6; nr = 3; nc = 3;
 6: bptr   = (int *)malloc( (nr+1)*sizeof(int) );
 7: row    = (int *)malloc( (nr+1)*sizeof(int) );
 8: col    = (int *)malloc( (nc+1)*sizeof(int) );
 9: ptr    = (int *)malloc( (bnnz+1)*sizeof(int) );
10: bindex = (int *)malloc( bnnz*sizeof(int) );
11: value  = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
12: lis_matrix_create(0,&A);
13: lis_matrix_set_size(A,0,n);
14:
15: bptr[0] = 0; bptr[1] = 1; bptr[2] = 3; bptr[3] = 6;
16: row[0]  = 0; row[1]  = 1; row[2]  = 3; row[3] = 4;
17: col[0]  = 0; col[1]  = 1; col[2]  = 3; col[3] = 4;
18: bindex[0] =  0; bindex[1] =  0; bindex[2] =  1; bindex[3] =  0;
19: bindex[4] =  1; bindex[5] =  2;
20: ptr[0]    =  0; ptr[1]    =  1; ptr[2]    =  3; ptr[3]    =  7;
21: ptr[4]    =  8; ptr[5]    = 10; ptr[6]    = 11;
22: value[0]  = 11; value[1]  = 21; value[2]  =  0; value[3]  = 22;
23: value[4]  = 32; value[5]  =  0; value[6]  = 33; value[7]  = 41;
24: value[8]  =  0; value[9]  = 43; value[10] = 44;
25:
26:  lis_matrix_set_vbr(nnz,nr,nc,bnnz,row,col,ptr,bptr,bindex,value,A);
27:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のVBR形式での格納方法を図\ref{fig:storage09_mpi}に
示す. 
2プロセス上にこの行列をVBR形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage09_mpi.eps} 
\caption{VBR形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage09_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           n,nnz,nr,nc,bnnz,my_rank;
 2: int           *row,*col,*ptr,*bptr,*bindex;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 7; bnnz = 3; nr = 2; nc = 3;}
 7: else             {n = 2; nnz = 4; bnnz = 3; nr = 1; nc = 3;}
 8: bptr   = (int *)malloc( (nr+1)*sizeof(int) );
 9: row    = (int *)malloc( (nr+1)*sizeof(int) );
10: col    = (int *)malloc( (nc+1)*sizeof(int) );
11: ptr    = (int *)malloc( (bnnz+1)*sizeof(int) );
12: bindex = (int *)malloc( bnnz*sizeof(int) );
13: value  = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
14: lis_matrix_create(MPI_COMM_WORLD,&A);
15: lis_matrix_set_size(A,n,0);
16: if( my_rank==0 ) {
17:     bptr[0] = 0; bptr[1] = 1; bptr[2] = 3;
18:     row[0]  = 0; row[1]  = 1; row[2]  = 3;
19:     col[0]  = 0; col[1]  = 1; col[2]  = 3; col[3] = 4;
20:     bindex[0] =  0; bindex[1] =  0; bindex[2] =  1;
21:     ptr[0]    =  0; ptr[1]    =  1; ptr[2]    =  3; ptr[3]    =  7;
22:     value[0]  = 11; value[1] = 21; value[2] =  0; value[3] = 22;
23:     value[4]  = 32; value[5] =  0; value[6] = 33;}
24: else {
25:     bptr[0] = 0; bptr[1] = 3;
26:     row[0]  = 3; row[1]  = 4;
27:     col[0]  = 0; col[1]  = 1; col[2]  = 3; col[3] = 4;
28:     bindex[0] =  0; bindex[1] =  1; bindex[2] =  2;
29:     ptr[0]    =  0; ptr[1]    =  1; ptr[2]    =  3; ptr[3]    =  4;
30:     value[0]  = 41; value[1]  =  0; value[2]  = 43; value[3]  = 44;}
31:  lis_matrix_set_vbr(nnz,nr,nc,bnnz,row,col,ptr,bptr,bindex,value,A);
32:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

VBR形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_vbr(int nnz, int nr, int nc, int bnnz, int row[],|\\
      \verb| int col[], int ptr[], int bptr[], int bindex[], LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_vbr(integer nnz, integer nr, integer nc,|\\
      \verb| integer bnnz, integer row(), integer col(), integer ptr(), integer bptr(),|\\ 
      \verb| integer bindex(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr) |
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Coordinate (COO)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Coordinate (COO)}
COOは3つの配列({\ttfamily row, col, value})に格納する. 
\begin{itemize}
\item 長さ$nnz$の倍精度配列{\ttfamily value}は非零要素を格納する. 
\item 長さ$nnz$の整数配列{\ttfamily row}は非零要素の行番号を格納する. 
\item 長さ$nnz$の整数配列{\ttfamily col}は非零要素の列番号を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のCOO形式での格納方法を図\ref{fig:storage10}に示す. 
この行列をCOO形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage10.eps} 
\end{flushleft}
\end{minipage}
\caption{COO形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage10}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n,nnz;
 2: int           *row,*col;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: n = 4; nnz = 8;
 6: row   = (int *)malloc( nnz*sizeof(int) );
 7: col   = (int *)malloc( nnz*sizeof(int) );
 8: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
 9: lis_matrix_create(0,&A);
10: lis_matrix_set_size(A,0,n);
11:
12: row[0] = 0; row[1] = 1; row[2] = 3; row[3] = 1;
13: row[4] = 2; row[5] = 2; row[6] = 3; row[7] = 3;
14: col[0] = 0; col[1] = 0; col[2] = 0; col[3] = 1;
15: col[4] = 1; col[5] = 2; col[6] = 2; col[7] = 3;
16: value[0] = 11; value[1] = 21; value[2] = 41; value[3] = 22;
17: value[4] = 32; value[5] = 33; value[6] = 43; value[7] = 44;
18:
19:  lis_matrix_set_coo(nnz,row,col,value,A);
20:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のCOO形式での格納方法を図\ref{fig:storage10_mpi}に
示す. 
2プロセス上にこの行列をCOO形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage10_mpi.eps} 
\caption{COO形式のデータ構造 (MPI版)}\label{fig:storage10_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           n,nnz,my_rank;
 2: int           *row,*col;
 3: LIS_SCALAR    *value;
 4: LIS_MATRIX    A;
 5: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 6: if( my_rank==0 ) {n = 2; nnz = 3;}
 7: else             {n = 2; nnz = 5;}
 8: row   = (int *)malloc( nnz*sizeof(int) );
 9: col   = (int *)malloc( nnz*sizeof(int) );
10: value = (LIS_SCALAR *)malloc( nnz*sizeof(LIS_SCALAR) );
11: lis_matrix_create(MPI_COMM_WORLD,&A);
12: lis_matrix_set_size(A,n,0);
13: if( my_rank==0 ) {
14:     row[0] = 0; row[1] = 1; row[2] = 1;
15:     col[0] = 0; col[1] = 0; col[2] = 1;
16:     value[0] = 11; value[1] = 21; value[2] = 22;}
17: else {
18:     row[0] = 3; row[1] = 2; row[2] = 2; row[3] = 3; row[4] = 3;
19:     col[0] = 0; col[1] = 1; col[2] = 2; col[3] = 2; col[4] = 3;
20:     value[0] = 41; value[1] = 32; value[2] = 33; value[3] = 43; value[4] = 44;}
21:  lis_matrix_set_coo(nnz,row,col,value,A);
22:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

COO形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_coo(int nnz, int row[], int col[], LIS_SCALAR value[],|\\
      \verb| LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_coo(integer nnz, integer row(), integer col(),|\\
      \verb| LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dense (DNS)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Dense (DNS)}
DNSは1つの配列({\ttfamily value})に格納する. 
\begin{itemize}
\item 長さ$n \times n$の倍精度配列{\ttfamily value}は列優先で要素を格納する. 
\end{itemize}
\subsubsection{行列の作り方 (逐次, OpenMP版)}
行列$A$のDNS形式での格納方法を図\ref{fig:storage11}に示す. 
この行列をDNS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\begin{minipage}{0.3\textwidth}
\begin{flushright}
$ 
A = \left(
\begin{array}{cccc}
11 &    &    &    \\
21 & 22 &    &    \\
   & 32 & 33 &    \\
41 &    & 43 & 44 \\
\end{array}\right)
$
\end{flushright}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{flushleft}
\includegraphics{storage11.eps} 
\end{flushleft}
\end{minipage}
\caption{DNS形式のデータ構造 (逐次, OpenMP版)}\label{fig:storage11}}
\end{figure}
\begin{itembox}[l]{逐次, OpenMP版}
\small
\begin{verbatim}
 1: int           n;
 2: LIS_SCALAR    *value;
 3: LIS_MATRIX    A;
 4: n = 4;
 5: value = (LIS_SCALAR *)malloc( n*n*sizeof(LIS_SCALAR) );
 6: lis_matrix_create(0,&A);
 7: lis_matrix_set_size(A,0,n);
 8:
 9: value[0] = 11; value[1] = 21; value[2] =  0; value[3] = 41;
10: value[4] =  0; value[5] = 22; value[6] = 32; value[7] =  0;
11: value[8] =  0; value[9] =  0; value[10]= 33; value[11]= 43;
12: value[12]=  0; value[13]=  0; value[14]=  0; value[15]= 44;
13:
14:  lis_matrix_set_dns(value,A);
15:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\newpage
\subsubsection{行列の作り方 (MPI版)}
2プロセス上への行列$A$のDNS形式での格納方法を図\ref{fig:storage11_mpi}に
示す. 
2プロセス上にこの行列をDNS形式で作成する場合, プログラムは以下のように記述する. 
\begin{figure}[h]
{\centering 
\includegraphics{storage11_mpi.eps} 
\caption{DNS形式のデータ構造 (MPI版)}\label{fig:storage11_mpi}}
\end{figure}
\begin{itembox}[l]{MPI版}
\small
\begin{verbatim}
 1: int           n,my_rank;
 2: LIS_SCALAR    *value;
 3: LIS_MATRIX    A;
 4: MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);
 5: if( my_rank==0 ) {n = 2;}
 6: else             {n = 2;}
 7: value = (LIS_SCALAR *)malloc( n*n*sizeof(LIS_SCALAR) );
 8: lis_matrix_create(MPI_COMM_WORLD,&A);
 9: lis_matrix_set_size(A,n,0);
10: if( my_rank==0 ) {
11:     value[0] = 11; value[1] = 21; value[2] =  0; value[3] = 22;
12:     value[4] =  0; value[5] =  0; value[6] =  0; value[7] =  0;}
13: else {
14:     value[0] =  0; value[1] = 41; value[2] = 32; value[3] =  0;
15:     value[4] = 33; value[5] = 43; value[6] =  0; value[7] = 44;}
16:  lis_matrix_set_dns(value,A);
17:  lis_matrix_assemble(A);
\end{verbatim}
\end{itembox}
\subsubsection{関連する関数}
\noindent
{\bf 配列の関連付け}

DNS形式に必要な配列を行列$A$に関連付けるには関数
\begin{itemize}
\item \verb|C       int lis_matrix_set_dns(LIS_SCALAR value[], LIS_MATRIX A)|
\item \verb|Fortran subroutine lis_matrix_set_dns(LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{itemize}
を用いる. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{関数}\label{sec:func}
本節では, ユーザが使用できる関数について述べる. 
関数の解説はCを基準に記述している. 配列はCでは0オリジン, Fortranでは1オリジンである. 
なお, Cでの各関数の戻り値, Fortranでの{\tt ierr}の値は以下のようになっている. 
\\ \\ \\
{\bf 戻り値}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_SUCCESS(0)] ~~~~~正常終了
\item[\tt LIS\_ILL\_OPTION(1)] ~~~~~オプションが不正
\item[\tt LIS\_BREAKDOWN(2)] ~~~~~ブレイクダウン
\item[\tt LIS\_OUT\_OF\_MEMORY(3)] ~~~~~メモリ不足
\item[\tt LIS\_MAXITER(4)] ~~~~~最大反復回数までに収束しなかった
\item[\tt LIS\_NOT\_IMPLEMENTED(5)] ~~~~~まだ実装されていない
\item[\tt LIS\_ERR\_FILE\_IO(6)] ~~~~~ファイルI/Oエラー
\end{namelist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ベクトル操作}
ベクトル$v$の次数を$global\_n$とする. 
ベクトル$v$を$nprocs$個のプロセスで行ブロック分割したときの
各ブロックの行数を$local\_n$とする. 
$global\_n$をグローバルな次数, $local\_n$をローカルな次数と呼ぶ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{lis\_vector\_create}
\begin{screen}
\verb|C       int lis_vector_create(LIS_Comm comm, LIS_VECTOR *vec)|\\
\verb|Fortran subroutine lis_vector_create(LIS_Comm comm, LIS_VECTOR vec, integer ierr)| 
\end{screen}
{\bf 機能}\\
\indent
ベクトルを作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_Comm] MPIコミュニケータ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt vec] ベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, {\tt comm}の値は無視される. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_destroy}
\begin{screen}
\verb|C       int lis_vector_destroy(LIS_VECTOR vec)|\\
\verb|Fortran subroutine lis_vector_destroy(LIS_VECTOR vec, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
不要になったベクトルをメモリから破棄する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt vec] メモリから破棄するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_duplicate}
\begin{screen}
\verb|C       int lis_vector_duplicate(void *vin, LIS_VECTOR *vout)|
\verb|Fortran subroutine lis_vector_duplicate(LIS_VECTOR vin, LIS_VECTOR vout,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
既存のベクトルまたは行列と同じ情報を持つベクトルを作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt vin] 複製元のベクトルまたは行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt vout] 複製先のベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
\verb|vin|には\verb|LIS_VECOTR|または\verb|LIS_MATRIX|を指定することが可能である. 
\verb|lis_vector_duplicate|関数は値はコピーされず, 領域のみ確保される. 
値もコピーしたい場合はこの関数の後に
\verb|lis_vector_copy|関数を用いる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{lis\_vector\_set\_size}
\begin{screen}
\verb|C       int lis_vector_set_size(LIS_VECTOR vec, int local_n, int global_n)|\\
\verb|Fortran subroutine lis_vector_set_size(LIS_VECTOR vec, integer local_n,|\\
\verb|         integer global_n, integer ierr)| 
\end{screen}
{\bf 機能}\\
\indent
ベクトルのサイズを設定する.
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt vec] ベクトル
\item[\tt local\_n] ベクトルのローカルな次数
\item[\tt global\_n] ベクトルのグローバルな次数
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
$local\_n$ か $global\_n$ のどちらか一方を与えなければならない. 
逐次, OpenMP版では, ベクトルの次数は$local\_n$ $=$ $global\_n$となる. 
したがって, \\
\verb|lis_vector_set_size(v,n,0)|
と\verb|lis_vector_set_size(v,0,n)|はどちらも次数$n$のベクトルを作成することを意味する. 

MPI版では, \verb|lis_vector_set_size(v,n,0)|とすると, 
各プロセス$p$に次数$n_p$の部分ベクトルを作成する. 
一方, \verb|lis_vector_set_size(v,0,n)|とすると
各プロセス$p$に次数$m_p$の部分ベクトルを作成する. ただし, $m_p$の値はライブラリ側で決定される. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_get\_size}
\begin{screen}
\verb|C       int lis_vector_get_size(LIS_VECTOR v, int *local_n, int *global_n)|
\verb|Fortran subroutine lis_vector_get_size(LIS_VECTOR v, integer local_n,|\\
\verb|         integer global_n, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$のサイズを得る. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt local\_n] ベクトルのローカルな次数
\item[\tt global\_n] ベクトルのグローバルな次数
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, $local\_n$ $=$ $global\_n$ となる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_get\_range}
\begin{screen}
\verb|C       int lis_vector_get_range(LIS_VECTOR v, int *is, int *ie)|
\verb|Fortran subroutine lis_vector_get_range(LIS_VECTOR v, integer is, integer ie,|\\
\verb|         integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
部分ベクトル$v$が全体ベクトルのどこに位置しているのかを調べる. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] 部分ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt is] 部分ベクトル$v$の全体ベクトル中での開始位置
\item[\tt ie] 部分ベクトル$v$の全体ベクトル中での終了位置+1
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, $n$次ベクトルでは$is=0$, $ie=n$ となる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_set\_value}
\begin{screen}
\verb|C       int lis_vector_set_value(int flag, int i, LIS_SCALAR value, LIS_VECTOR v)|
\verb|Fortran subroutine lis_vector_set_value(integer flag, integer i, LIS_SCALAR value,|\\
\verb|         LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$の$i$行目にスカラ値$value$を代入する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt flag] \begin{description}
\item[\tt LIS\_INS\_VALUE] 挿入    : {\tt v[$i$] = $value$}
\item[\tt LIS\_ADD\_VALUE] 加算代入: {\tt v[$i$] = v[$i$] + $value$}
\end{description}
\item[\tt i] 代入する場所
\item[\tt value] 代入するスカラ値
\item[\tt v] 代入されるベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] $i$行目にスカラ値$value$が代入されたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
MPI版では, 部分ベクトルの$i$行目ではなく全体ベクトルの$i$行目を指定する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_get\_value}
\begin{screen}
\verb|C       int lis_vector_get_value(LIS_VECTOR v, int i, LIS_SCALAR *value)|
\verb|Fortran subroutine lis_vector_get_value(LIS_VECTOR v, integer i, LIS_SCALAR value,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$の$i$行目の値を$value$に取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt i] 取得する場所
\item[\tt v] 値を取得するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] スカラ値
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
MPI版では, 部分ベクトルの$i$行目ではなく全体ベクトルの$i$行目を指定する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_set\_values}
\begin{screen}
\verb|C       int lis_vector_set_values(int flag, int count, int index[],|\\
\verb|         LIS_SCALAR value[], LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_vector_set_values(integer flag, integer count,|\\
\verb|         integer index(), LIS_SCALAR value(), LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$の{\tt index[$i$]}行目にスカラ値{\tt value[$i$]}を代入する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt flag] \begin{description}
\item[\tt LIS\_INS\_VALUE] 挿入    : {\tt v[index[$i$]] = value[$i$]}
\item[\tt LIS\_ADD\_VALUE] 加算代入: {\tt v[index[$i$]] = v[index[$i$]] + value[$i$]}
\end{description}
\item[\tt count] 代入するスカラ値を格納する配列の要素数
\item[\tt index] 代入する場所を格納する配列
\item[\tt value] 代入するスカラ値を格納する配列
\item[\tt v] 代入されるベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] {\tt index[$i$]}行目にスカラ値{\tt value[$i$]}が代入されたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
MPI版では, 部分ベクトルの{\tt index[$i$]}行目ではなく全体ベクトルの{\tt index[$i$]}行目を指定する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_get\_values}
\begin{screen}
\verb|C       int lis_vector_get_values(LIS_VECTOR v, int start, int count,|\\
\verb|         LIS_SCALAR value[])|\\
\verb|Fortran subroutine lis_vector_get_values(LIS_VECTOR v, integer start,|\\
\verb|         integer count, LIS_SCALAR value(), integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$の$start+i$行目の値 ($i=0,1,..., count-1$)を{\tt
value[$i$]}に格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt start] 取得する場所の始点
\item[\tt count] 取得するスカラ値の個数
\item[\tt v] 値を取得するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] 取得したスカラ値を格納するベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
MPI版では, 部分ベクトルの$start+i$行目ではなく全体ベクトルの$start+i$行目を指定する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_scatter}
\begin{screen}
\verb|C       int lis_vector_scatter(LIS_SCALAR value[], LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_vector_scatter(LIS_SCALAR value(), LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$の$i$行目の値 ($i=0,1,...,global\_n-1$)を{\tt value[$i$]}から取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] 取得するスカラ値を格納するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] 値を取得したベクトル
\item[\tt ierr] リターンコード
\end{namelist}
\indent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_gather}
\begin{screen}
\verb|C       int lis_vector_gather(LIS_VECTOR v, LIS_SCALAR value[])|\\
\verb|Fortran subroutine lis_vector_gather(LIS_VECTOR v, LIS_SCALAR value(), integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル{\tt v}の$i$行目の値 ($i=0,1,..., global\_n-1$)を{\tt
value[$i$]}に格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] 値を取得するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] 取得したスカラ値を格納するベクトル
\item[\tt ierr] リターンコード
\end{namelist}
\indent
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_copy}
\begin{screen}
\verb|C       int lis_vector_copy(LIS_VECTOR x, LIS_VECTOR y)|\\
\verb|Fortran subroutine lis_vector_copy(LIS_VECTOR x, LIS_VECTOR y, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルの要素をコピーする. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] コピー元ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt y] コピー先ベクトル
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_set\_all}
\begin{screen}
\verb|C       int lis_vector_set_all(LIS_SCALAR value, LIS_VECTOR x)|
\verb|Fortran subroutine lis_vector_set_all(LIS_SCALAR value, LIS_VECTOR x, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルのすべての要素にスカラ値$value$を代入する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] 代入するスカラ値
\item[\tt v] 代入されるベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] すべての要素に$value$が代入されたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_is\_null}
\begin{screen}
\verb|C       int lis_vector_is_null(LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_vector_is_null(LIS_VECTOR v,integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル$v$が利用可能かどうかを調べる. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] \begin{description}
\item[\tt LIS\_TRUE] 利用可能
\item[\tt LIS\_FALSE] 利用不可
\end{description}
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{行列操作}
行列$A$の次数を$global\_n$ $\times$ $global\_n$とする. 
行列$A$を$nprocs$個のプロセスで行ブロック分割したときの
各部分行列の行数を$local\_n$とする. 
$global\_n$をグローバルな行数, $local\_n$をローカルな行数と呼ぶ. 
  \subsubsection{lis\_matrix\_create}
\begin{screen}
\verb|C       int lis_matrix_create(LIS_Comm comm, LIS_MATRIX *A)|
\verb|Fortran subroutine lis_matrix_create(LIS_Comm comm, LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列を作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_Comm] MPIコミュニケータ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, {\tt comm}の値は無視される. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_destroy}
\begin{screen}
\verb|C       int lis_matrix_destroy(LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_destroy(LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
不要になった行列をメモリから破棄する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] メモリから破棄する行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_duplicate}
\begin{screen}
\verb|C       int lis_matrix_duplicate(LIS_MATRIX Ain, LIS_MATRIX *Aout)|
\verb|Fortran subroutine lis_matrix_duplicate(LIS_MATRIX Ain, LIS_MATRIX Aout,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
既存の行列と同じ情報を持つ行列を作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Ain] 複製元の行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Aout] 複製先の行列
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
\verb|lis_matrix_duplicate|関数は行列の要素の値はコピーされず, 領域のみ確保される. 
要素の値もコピーしたい場合は\verb|lis_matrix_copy|関数を用いる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_malloc}
\begin{screen}
\verb|C       int lis_matrix_malloc(LIS_MATRIX A, int nnz_row, int nnz[])|
\verb|Fortran subroutine lis_matrix_malloc(LIS_MATRIX A, integer nnz_row, integer nnz[],|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列の領域を確保する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt nnz\_row] 平均非零要素数
\item[\tt nnz] 各行の非零要素数の配列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
$nnz\_row$ または $nnz$ のどちらか一方を指定する. 
この関数は, \verb|lis_matrix_set_value| で効率よく要素を代入できるように, あらかじめ
領域を確保する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_value}
\begin{screen}
\verb|C       int lis_matrix_set_value(int flag, int i, int j, LIS_SCALAR value,|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_value(integer flag, integer i, integer j,|\\
\verb|         LIS_SCALAR value, LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列$A$の$i$行$j$列目に要素を代入する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt flag] \begin{description}
\item[\tt LIS\_INS\_VALUE] 挿入    : {$A(i,j) = value$}
\item[\tt LIS\_ADD\_VALUE] 加算代入: {$A(i,j) = A(i,j) + value$}
\end{description}
\item[\tt i] 行列の行番号
\item[\tt j] 行列の列番号
\item[\tt value] 代入するスカラ値
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] $i$行$j$列目に要素が代入された行列
\item[\tt ierr] リターンコード
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
MPI版では, 部分行列の$i$行$j$列目ではなく全体行列の$i$行$j$列目を指定する. 

\verb|lis_matrix_set_value|関数は代入された値を一時的な内部形式で
格納するため, \verb|lis_matrix_set_value|を用いた後には必ず
\verb|lis_matrix_assemble|関数を呼び出さなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_assemble}
\begin{screen}
\verb|C       int lis_matrix_assemble(LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_assemble(LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列をライブラリで利用可能にする. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 利用可能になった行列
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_size}
\begin{screen}
\verb|int lis_matrix_set_size(LIS_MATRIX A, int local_n, int global_n)|
\verb|Fortran subroutine lis_matrix_set_size(LIS_MATRIX A, integer local_n,|\\
\verb|         integer global_n, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列のサイズを設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt local\_n] 行列$A$のローカルな行数
\item[\tt global\_n] 行列$A$のグローバルな行数
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
$local\_n$ か $global\_n$ のどちらか一方を与えなければならない. 

逐次, OpenMP版では, 行列のサイズは$local\_n$ $=$ $global\_n$となる. 
したがって, \\
\verb|lis_matrix_set_size(A,n,0)|
と\verb|lis_matrix_set_size(A,0,n)|はともに$n \times n$のサイズを設定することを意味する. 

MPI版では, \verb|lis_matrix_set_size(A,n,0)|とすると, 
各プロセス$p$で行列サイズが$n_p \times N$となるように設定する. ここで,
$N$は各プロセスの$n_p$の総和である. \\
一方, \verb|lis_matrix_set_size(A,0,n)|とすると
各プロセス$p$で行列サイズが$m_p \times n$となるように設定する. ここで, $m_p$は部分行列の行数で
この値はライブラリ側で決定される. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_get\_size}
\begin{screen}
\verb|C       int lis_matrix_get_size(LIS_MATRIX A, int *local_n, int *global_n)|
\verb|Fortran subroutine lis_matrix_get_size(LIS_MATRIX A, integer local_n,|\\
\verb|         integer global_n, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列のサイズを取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt local\_n] 行列$A$のローカルな行数
\item[\tt global\_n] 行列$A$のグローバルな行数
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, $local\_n$ $=$ $global\_n$ となる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_get\_range}
\begin{screen}
\verb|C       int lis_matrix_get_range(LIS_MATRIX A, int *is, int *ie)|
\verb|Fortran subroutine lis_matrix_get_range(LIS_MATRIX A, integer is, integer ie,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
部分行列$A$が全体行列のどこに位置しているのかを調べる. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 部分行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt is] 部分行列$A$の全体行列中での開始位置
\item[\tt ie] 部分行列$A$の全体行列中での終了位置+1
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
逐次, OpenMP版では, $n \times n$行列では$is=0$, $ie=n$となる. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_type}
\begin{screen}
\verb|C       int lis_matrix_set_type(LIS_MATRIX A, int matrix_type)|
\verb|Fortran subroutine lis_matrix_set_type(LIS_MATRIX A, int matrix_type, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列の格納形式を設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt matrix\_type] 行列の格納形式
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
行列作成時に$A$の \verb+matrix_type+ は \verb+LIS_MATRIX_CRS+ となっている. 
以下に \verb+matrix_type+ に指定可能な格納形式を示す. 
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{lll}\hline\hline
格納形式  & & matrix\_type \\ \hline
Compressed Row Storage & (CRS) & \verb|LIS_MATRIX_CRS| \\
Compressed Column Storage & (CCS) & \verb|LIS_MATRIX_CCS| \\
Modified Compressed Sparse Row & (MSR) & \verb|LIS_MATRIX_MSR| \\
Diagonal &(DIA) & \verb|LIS_MATRIX_DIA| \\
Ellpack-Itpack generalized diagonal &(ELL) & \verb|LIS_MATRIX_ELL| \\
Jagged Diagonal &(JDS) & \verb|LIS_MATRIX_JDS| \\
Block Sparse Row & (BSR) & \verb|LIS_MATRIX_BSR| \\
Block Sparse Column &(BSC) & \verb|LIS_MATRIX_BSC| \\
Variable Block Row &(VBR) & \verb|LIS_MATRIX_VBR| \\
Dense &	(DNS) & \verb|LIS_MATRIX_DNS| \\
Coordinate & (COO) & \verb|LIS_MATRIX_COO| \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_get\_type}
\begin{screen}
\verb|C       int lis_matrix_get_type(LIS_MATRIX A, int *matrix_type)|
\verb|Fortran subroutine lis_matrix_get_type(LIS_MATRIX A, integer matrix_type,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列の格納形式を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt matrix\_type] 行列の格納形式
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_blocksize}
\begin{screen}
\verb|C       int lis_matrix_set_blocksize(LIS_MATRIX A, int bnr, int bnc, int row[],|\\
\verb|         int col[])|\\
\verb|Fortran subroutine lis_matrix_set_blocksize(LIS_MATRIX A, integer bnr, integer bnc,|\\
\verb|         integer row[], integer col[], integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
BSR, BSC, VBRのブロックサイズ, 分割情報を設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt bnr] BSR(BSC)の行ブロックサイズ, またはVBRの行ブロック数
\item[\tt bnc] BSR(BSC)の列ブロックサイズ, またはVBRの列ブロック数
\item[\tt row] VBRの行分割情報の配列
\item[\tt col] VBRの列分割情報の配列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_convert}
\begin{screen}
\verb|C       int lis_matrix_convert(LIS_MATRIX Ain, LIS_MATRIX Aout)|\\
\verb|Fortran subroutine lis_matrix_convert(LIS_MATRIX Ain, LIS_MATRIX Aout, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列$Ain$を指定の格納形式に変換した行列$Aout$を作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Ain] 変換元の行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Aout] 指定の格納形式に変換された行列
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
変換する格納形式の指定は \verb|lis_matrix_set_type| 
を用いて \verb|Aout| に設定する. 
BSR, BSC, VBRのブロックサイズ等の情報はユーザが \verb|lis_matrix_set_blocksize| を
用いて \verb|Aout| に設定する. 

元の行列から指定の格納形式への変換で以下の表の○となっている経路は直接変換され, 
それ以外は記載されている形式を経由してから指定の格納形式に変換される. 
また, 表に記載されていない経路はCRSを経由してから指定の格納形式に変換される.  
\\ \vspace*{5mm}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
元＼先 & CRS & CCS & MSR & DIA & ELL & JDS & BSR & BSC & VBR & DNS & COO \\ \hline
CRS    &     &  ○  &  ○  &  ○  &  ○  &  ○  &  ○  &  CCS  &  ○  &  ○  &  ○  \\ \hline
COO    &  ○  &  ○  &  ○  & CRS  & CRS & CRS & CRS & CCS & CRS & CRS &    \\ \hline
\end{tabular}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_copy}
\begin{screen}
\verb|C       int lis_matrix_copy(LIS_MATRIX Ain, LIS_MATRIX Aout)|
\verb|Fortran subroutine lis_matrix_copy(LIS_MATRIX Ain, LIS_MATRIX Aout, integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
行列の要素をコピーする. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Ain] コピー元の行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt Aout] コピー先の行列
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_get\_diagonal}
\begin{screen}
\verb|C       int lis_matrix_get_diagonal(LIS_MATRIX A, LIS_VECTOR d)|\\
\verb|Fortran subroutine lis_matrix_get_diagonal(LIS_MATRIX A, LIS_VECTOR d, integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
行列$A$の対角部分をベクトル$d$にコピーする. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt d] 対角要素が格納されたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_set\_crs}
\begin{screen}
\verb|C       int lis_matrix_set_crs(int nnz, int ptr[], int index[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_crs(integer nnz, integer row(), integer index(),|\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|

\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したCRS形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零要素数
\item[\tt ptr, index, value] CRS形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_crs|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_ccs}
\begin{screen}
\verb|C       int lis_matrix_set_ccs(int nnz, int ptr[], int index[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_ccs(integer nnz, integer row(), integer index(),|\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したCCS形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零要素数
\item[\tt ptr, index, value] CCS形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_ccs|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_msr}
\begin{screen}
\verb|C       int lis_matrix_set_msr(int nnz, int ndz, int index[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)| \\
\verb|Fortran subroutine lis_matrix_set_msr(integer nnz, integer ndz, integer index(),|\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したMSR形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零要素数
\item[\tt ndz] 対角部分の零要素数
\item[\tt index, value] MSR形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_msr|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_dia}
\begin{screen}
\verb|C       int lis_matrix_set_dia(int nnd, int index[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_dia(integer nnd, integer index(), |\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したDIA形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnd] 非零な対角要素の本数
\item[\tt index, value] DIA形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_dia()|を用いた後には必ず
\verb|lis_matrix_assemble()|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_ell}
\begin{screen}
\verb|C       int lis_matrix_set_ell(int maxnzr, int index[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_ell(integer maxnzr, integer index(),|\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したELL形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt maxnzr] 各行の非零要素数の最大値
\item[\tt index, value] ELL形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_ell|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_jds}
\begin{screen}
\verb|C       int lis_matrix_set_jds(int nnz, int maxnzr, int perm[], int ptr[], |\\
\verb|         int index[], LIS_SCALAR value[], LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_jds(integer nnz, integer maxnzr, integer ptr(),|\\
\verb|         integer index(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したJDS形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零要素数
\item[\tt maxnzr] 各行の非零要素数の最大値
\item[\tt perm, ptr, index, value] JDS形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_jds|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_bsr}
\begin{screen}
\verb|C       int lis_matrix_set_bsr(int bnr, int bnc, int bnnz, int bptr[], int bindex[],|\\
\verb|         LIS_SCALAR value[], LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_bsr(integer bnr, integer bnc, integer bnnz,|\\
\verb|         integer bptr(), integer bindex(), LIS_SCALAR value(), LIS_MATRIX A,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したBSR形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt bnr] 行ブロックサイズ
\item[\tt bnc] 列ブロックサイズ
\item[\tt bnnz] 非零ブロック数
\item[\tt bptr, bindex, value] BSR形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_bsr|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_set\_bsc}
\begin{screen}
\verb|C       int lis_matrix_set_bsc(int bnr, int bnc, int bnnz, int bptr[], int bindex[],|\\
\verb|         LIS_SCALAR value[], LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_bsc(integer bnr, integer bnc, integer bnnz,|\\
\verb|         integer bptr(), integer bindex(), LIS_SCALAR value(), LIS_MATRIX A,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したBSC形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt bnr] 行ブロックサイズ
\item[\tt bnc] 列ブロックサイズ
\item[\tt bnnz] 非零ブロック数
\item[\tt bptr, bindex, value] BSC形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_bsc|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_set\_vbr}
\begin{screen}
\verb|C       int lis_matrix_set_vbr(int nnz, int nr, int nc, int bnnz, int row[],|\\
\verb|         int col[], int ptr[], int bptr[], int bindex[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_vbr(integer nnz, integer nr, integer nc,|\\
\verb|         integer bnnz, integer row(), integer col(), integer ptr(), integer bptr(),|\\ 
\verb|         integer bindex(), LIS_SCALAR value(), LIS_MATRIX A, integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したVBR形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零ブロックの全要素数
\item[\tt nr] 行ブロック数
\item[\tt nc] 列ブロック数
\item[\tt bnnz] 非零ブロック数
\item[\tt row, col, ptr, bptr, bindex, value] VBR形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_vbr|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_matrix\_set\_coo}
\begin{screen}
\verb|C       int lis_matrix_set_coo(int nnz, int row[], int col[], LIS_SCALAR value[],|\\
\verb|         LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_coo(integer nnz, integer row(), integer col(),|\\
\verb|         LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したCOO形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nnz] 非零要素数
\item[\tt row, col, value] COO形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_coo|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_set\_dns}
\begin{screen}
\verb|C       int lis_matrix_set_dns(LIS_SCALAR value[], LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_matrix_set_dns(LIS_SCALAR value(), LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザ自身が作成したDNS形式に必要な配列を行列$A$に関連付ける. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt value] DNS形式の配列
\item[\tt A] 行列
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 関連付けられた行列
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
\verb|lis_matrix_set_dns|を用いた後には必ず
\verb|lis_matrix_assemble|を呼び出さなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{ベクトルと行列の計算}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_scale}
\begin{screen}
\verb|C       int lis_vector_scale(LIS_SCALAR alpha, LIS_VECTOR x)|
\verb|Fortran subroutine lis_vector_scale(LIS_SCALAR alpha, LIS_VECTOR x, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルのすべての値を$\alpha$倍する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt alpha] スカラ値$\alpha$
\item[\tt x] $\alpha$倍するベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] すべての要素が$\alpha$倍されたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_dot}
\begin{screen}
\verb|C       int lis_vector_dot(LIS_VECTOR x, LIS_VECTOR y, LIS_SCALAR *val)|
\verb|Fortran subroutine lis_vector_dot(LIS_VECTOR x, LIS_VECTOR y, LIS_SCALAR val,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルの内積$x^{T}y$を計算する.  
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] ベクトル
\item[\tt y] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt val] 内積の値
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_nrm1}
\begin{screen}
\verb|C       int lis_vector_nrm1(LIS_VECTOR x, LIS_REAL *val)|\\
\verb|Fortran subroutine lis_vector_nrm1(LIS_VECTOR x, LIS_REAL val, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルの1ノルムを計算する.  
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt val] ベクトルの1ノルム
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_nrm2}
\begin{screen}
\verb|C       int lis_vector_nrm2(LIS_VECTOR x, LIS_REAL *val)|\\
\verb|Fortran subroutine lis_vector_nrm2(LIS_VECTOR x, LIS_REAL val, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルの2ノルムを計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt val] ベクトルの2ノルム
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_nrmi}
\begin{screen}
\verb|C       int lis_vector_nrmi(LIS_VECTOR x, LIS_REAL *val)|\\
\verb|Fortran subroutine lis_vector_nrmi(LIS_VECTOR x, LIS_REAL val, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトルの無限大ノルムを計算する.
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt val] ベクトルの無限大ノルム
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_vector\_axpy}
\begin{screen}
\verb|C       int lis_vector_axpy(LIS_SCALAR alpha, LIS_VECTOR x, LIS_VECTOR y)|
\verb|Fortran subroutine lis_vector_axpy(LIS_SCALAR alpha, LIS_VECTOR x, LIS_VECTOR y,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル和$y = \alpha x + y$を計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt alpha] スカラ値
\item[\tt x, y] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt y] $\alpha x + y$の計算結果 (ベクトル$y$の値は上書きされる) 
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_xpay}
\begin{screen}
\verb|C       int lis_vector_xpay(LIS_VECTOR x, LIS_SCALAR alpha, LIS_VECTOR y)|
\verb|Fortran subroutine lis_vector_xpay(LIS_VECTOR x, LIS_SCALAR alpha, LIS_VECTOR y,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル和$y = x + \alpha y$を計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt alpha] スカラ値
\item[\tt x, y] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt y] $x + \alpha y$の計算結果 (ベクトル$y$の値は上書きされる) 
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_vector\_axpyz}
\begin{screen}
\verb|C       int lis_vector_axpyz(LIS_SCALAR alpha, LIS_VECTOR x, LIS_VECTOR y,|\\
\verb|         LIS_VECTOR z)|\\
\verb|Fortran subroutine lis_vector_axpyz(LIS_SCALAR alpha, LIS_VECTOR x, LIS_VECTOR y,|\\
\verb|         LIS_VECTOR z, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ベクトル和$z = \alpha x + y$を計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt alpha] スカラ値
\item[\tt x, y] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt z] $x + \alpha y$の計算結果
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matrix\_scaling}
\begin{screen}
\verb|C       int lis_matrix_scaling(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR d, int action)|\\
\verb|Fortran subroutine lis_matrix_scaling(LIS_MATRIX A, LIS_VECTOR b,|\\
\verb|         LIS_VECTOR d, integer action, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列のスケーリングを行う. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] スケーリングを行う行列
\item[\tt b] スケーリングを行うベクトル
\item[\tt action] \begin{description}
\item[\tt LIS\_SCALE\_JACOBI] Jacobiスケーリング $D^{-1}Ax=D^{-1}b$, た
	   だし$D$は$A=(a_{ij})$の対角部分
\item[\tt LIS\_SCALE\_SYMM\_DIAG] 対角スケーリング
	   $D^{-1/2}AD^{-1/2}x=D^{-1/2}b$, ただし$D^{-1/2}$は対角要素に$1/\sqrt{a_{ii}}$を持つ対角行列
\end{description}
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt d]  $D^{-1}$または$D^{-1/2}$の対角部分を格納したベクトル
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matvec}
\begin{screen}
\verb|C       void lis_matvec(LIS_MATRIX A, LIS_VECTOR x, LIS_VECTOR y)|\\
\verb|Fortran subroutine lis_matvec(LIS_MATRIX A, LIS_VECTOR x, LIS_VECTOR y)|
\end{screen}
{\bf 機能}\\
\indent
行列ベクトル積$y = Ax$を計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt x] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt y] ベクトル
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_matvect}
\begin{screen}
\verb|C       void lis_matvect(LIS_MATRIX A, LIS_VECTOR x, LIS_VECTOR y)|\\
\verb|Fortran subroutine lis_matvect(LIS_MATRIX A, LIS_VECTOR x, LIS_VECTOR y)|
\end{screen}
{\bf 機能}\\
\indent
転置行列ベクトル積$y = A^{T}x$を計算する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt x] ベクトル
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt y] ベクトル
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{線型方程式系の求解}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_create}
\begin{screen}
\verb|C       int lis_solver_create(LIS_SOLVER *solver)|\\
\verb|Fortran subroutine lis_solver_create(LIS_SOLVER solver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバ (線型方程式系解法の情報を格納する構造体) を作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ソルバは線型方程式系解法の情報を持つ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_destroy}
\begin{screen}
\verb|C       int lis_solver_destroy(LIS_SOLVER solver)|\\
\verb|Fortran subroutine lis_solver_destroy(LIS_SOLVER solver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
不要になったソルバをメモリから破棄する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] メモリから破棄するソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solver\_set\_option}
  \label{sec:setoptions}
\begin{screen}
\verb|C       int lis_solver_set_option(char *text, LIS_SOLVER solver)|
\verb|Fortran subroutine lis_solver_set_option(character text, LIS_SOLVER solver,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
線型方程式系解法のオプションをソルバに設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt text] コマンドラインオプション
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
以下に指定可能なコマンドラインオプションを示す. \verb=-i {cg|1}=は\verb=-i cg=または\verb=-i 1=
を意味する. \\
\verb=-maxiter [1000]=は\verb=-maxiter=のデフォルト値が$1000$であることを意味する. 
\\
\\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 線型方程式系解法の指定} デフォルト: \verb=-i bicg= \\
\begin{tabular}{l|lll}\hline\hline
 線型方程式系解法        & オプション              &  補助オプション  & \\ \hline
 CG          & \verb=-i {cg|1}=         &    \\ 
 BiCG        & \verb=-i {bicg|2}=       &    \\
 CGS         & \verb=-i {cgs|3}=        &    \\
 BiCGSTAB    & \verb=-i {bicgstab|4}=   &    \\
 BiCGSTAB(l) & \verb=-i {bicgstabl|5}=  & \verb=-ell [2]=      & 次数$l$ \\
 GPBiCG      & \verb=-i {gpbicg|6}=     &    \\
 TFQMR       & \verb=-i {tfqmr|7}=      &    \\
 Orthomin(m) & \verb=-i {orthomin|8}=   & \verb=-restart [40]= & リスタート値$m$  \\
 GMRES(m)    & \verb=-i {gmres|9}=      & \verb=-restart [40]= & リスタート値$m$  \\ 
 Jacobi      & \verb=-i {jacobi|10}=    &    \\
 Gauss-Seidel& \verb=-i {gs|11}=        &    \\
 SOR         & \verb=-i {sor|12}=       & \verb=-omega [1.9]=  & 緩和係数$\omega$ ($0<\omega<2$) \\
 BiCGSafe    & \verb=-i {bicgsafe|13}=  &    \\
 CR          & \verb=-i {cr|14}=        &    \\ 
 BiCR        & \verb=-i {bicr|15}=      &    \\
 CRS         & \verb=-i {crs|16}=       &    \\
 BiCRSTAB    & \verb=-i {bicrstab|17}=  &    \\
 GPBiCR      & \verb=-i {gpbicr|18}=    &    \\
 BiCRSafe    & \verb=-i {bicrsafe|19}=  &    \\
 FGMRES(m)   & \verb=-i {fgmres|20}=    & \verb=-restart [40]= & リスタート値$m$  \\ 
 IDR(s)      & \verb=-i {idrs|21}=      & \verb=-irestart [2]= & リスタート値$s$  \\ 
 MINRES      & \verb=-i {minres|22}=    &    \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 前処理の指定} デフォルト: \verb=-p none=\\
\begin{tabular}{l|lll}\hline\hline
前処理   & オプション           & 補助オプション \\ \hline
なし     & \verb=-p {none|0}=    &   \\
Jacobi   & \verb=-p {jacobi|1}=  &     \\
ILU(k)   & \verb=-p {ilu|2}=     & \verb=-ilu_fill [0]=    & フィルインレベル$k$ \\
SSOR     & \verb=-p {ssor|3}=    & \verb=-ssor_w [1.0]=    & 緩和係数$\omega$ ($0<\omega<2$) \\
Hybrid   & \verb=-p {hybrid|4}=  & \verb=-hybrid_i [sor]=  & 線型方程式系解法 \\
         &                       & \verb=-hybrid_maxiter [25]= & 最大反復回数 \\
         &                       & \verb=-hybrid_tol [1.0e-3]= & 収束判定基準 \\
         &                       & \verb=-hybrid_w [1.5]=      & SORの緩和係数$\omega$ ($0<\omega<2$) \\
         &                       & \verb=-hybrid_ell [2]=      & BiCGSTAB(l)の次数$l$\\
         &                       & \verb=-hybrid_restart [40]= & GMRES(m), Orthomin(m)の \\
         &                       &                             & リスタート値$m$ \\
I+S      & \verb=-p {is|5}=      & \verb=-is_alpha [1.0]=  & $I+\alpha S^{(m)}$型前処理のパラメータ$\alpha$ \\
         &                       & \verb=-is_m [3]=        & $I+\alpha S^{(m)}$型前処理のパラメータ$m$ \\
SAINV    & \verb=-p {sainv|6}=   & \verb=-sainv_drop [0.05]=    & ドロップ基準\\
SA-AMG   & \verb=-p {saamg|7}=   & \verb=-saamg_unsym [false]=     & 非対称版の選択 \\
         &                       &                                 & (行列構造は対称とする) \\
         &                       & \verb=-saamg_theta [0.05|0.12]= & ドロップ基準 $a^2_{ij}\le\theta^2|a_{ii}||a_{jj}|$ \\
         &                       &                             & (対称\verb=|=非対称) \\
Crout ILU& \verb=-p {iluc|8}=    & \verb=-iluc_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-iluc_rate [5.0]=     & 最大フィルイン数の倍率 \\
ILUT     & \verb=-p {ilut|9}=    & \verb=-ilut_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-ilut_rate [5.0]=     & 最大フィルイン数の倍率 \\
Additive Schwarz  & \verb=-adds true=   &  \verb=-adds_iter [1]= & 繰り返し回数   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf その他のオプション}\\
\begin{tabular}{l|ll}\hline\hline
オプション &                          \\ \hline
\verb=-maxiter [1000]= & 最大反復回数         \\ 
\verb=-tol [1.0e-12]=  & 収束判定基準              \\
\verb=-print [0]=      & 残差の画面表示                 \\
                       & \verb=-print {none|0}     =  何もしない \\
                       & \verb=-print {mem|1}      =  収束履歴をメモリに保存する\\
                       & \verb=-print {out|2}      =  収束履歴を画面に表示する\\
                       & \verb=-print {all|3}      =  収束履歴をメモリに保存し画面に表示する\\
\verb=-scale [0]=      & スケーリングの選択. スケーリング結果は元の行列, ベクトルに上書きされる \\
                       & \verb=-scale {none|0}     =  スケーリングなし \\ 
                       & \verb=-scale {jacobi|1}   =  Jacobiスケーリング $D^{-1}Ax=D^{-1}b$ \\
                       & \verb=                    =  ($D$は$A=(a_{ij})$の対角部分)\\
                       & \verb=-scale {symm_diag|2}=  対角スケーリング $D^{-1/2}AD^{-1/2}x=D^{-1/2}b$ \\
                       & \verb=                    =  ($D^{-1/2}$は対角要素に$1/\sqrt{a_{ii}}$を持つ対角行列) \\ 
\verb=-initx_zeros [true]= & 初期ベクトル$x_{0}$の振舞い  \\
                       & \verb=-initx_zeros {false|0}     =  与えられた値を使用 \\
                       & \verb=-initx_zeros {true|1}      =  すべての要素を$0$にする\\
\verb=-omp_num_threads [t]= & 実行スレッド数         \\ 
                            & \verb=t=は最大スレッド数 \\
\verb=-storage [0]=    & 行列格納形式 \\
\verb=-storage_block [2]= & BSR, BSCのブロックサイズ \\ 
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 演算精度} デフォルト: \verb=-f double=\\
\begin{tabular}{l|lll}\hline\hline
精度     & オプション           & 補助オプション \\ \hline
倍精度   & \verb=-f {double|0}=    &   \\
4倍精度  & \verb=-f {quad|1}=    &   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solver\_set\_optionC}
\begin{screen}
\verb|C       int lis_solver_set_optionC(LIS_SOLVER solver)|\\
\verb|Fortran subroutine lis_solver_set_optionC(LIS_SOLVER solver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザプログラム実行時にコマンドラインで指定された線型方程式系解法のオプションをソルバに設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solve}
\begin{screen}
\verb|C       int lis_solve(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x, LIS_SOLVER solver)|\\
\verb|Fortran subroutine lis_solve(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
\verb|         LIS_SOLVER solver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
指定された解法で線型方程式系$Ax=b$を解く. 
ソルバに与えられた出力は
\verb|lis_solver_get_iters|, \verb|lis_solver_get_time|, 
\verb|lis_solver_get_residualnorm|に格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 係数行列
\item[\tt b] 右辺ベクトル
\item[\tt x] 初期ベクトル
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] 解
\item[\tt solver] 反復回数, 計算時間等の情報
\item[\tt ierr] リターンコード (0)
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solve\_kernel}
\begin{screen}
\verb|C       int lis_solve_kernel(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
\verb|         LIS_SOLVER solver, LIS_PRECON precon)|\\
\verb|Fortran subroutine lis_solve_kernel(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
\verb|         LIS_SOLVER solver, LIS_PRECON precon, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
指定された解法について, 外部で定義された前処理を用いて線型方程式系$Ax=b$を解く. 
ソルバに与えられた出力は
\verb|lis_solver_get_iters|, \verb|lis_solver_get_time|, 
\verb|lis_solver_get_residualnorm|に格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 係数行列
\item[\tt b] 右辺ベクトル
\item[\tt x] 初期ベクトル
\item[\tt solver] ソルバ
\item[\tt precon] 前処理
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt x] 解
\item[\tt solver] 反復回数, 計算時間等の情報
\item[\tt ierr] リターンコード (0)
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solver\_get\_status}
\begin{screen}
\verb|C       int lis_solver_get_status(LIS_SOLVER solver, int *status)|\\
\verb|Fortran subroutine lis_solver_get_status(LIS_SOLVER solver, integer status,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから状態を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt status] 状態
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solver\_get\_iters}
\begin{screen}
\verb|C       int lis_solver_get_iters(LIS_SOLVER solver, int *iters)|\\
\verb|Fortran subroutine lis_solver_get_iters(LIS_SOLVER solver, integer iters,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから反復回数を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt iters] 反復回数
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_get\_itersex}
\begin{screen}
\verb|C       int lis_solver_get_itersex(LIS_SOLVER solver, int *iters,|\\
\verb|         int *iters_double, int *iters_quad)|\\
\verb|Fortran subroutine lis_solver_get_itersex(LIS_SOLVER solver, integer iters,|\\
\verb|         integer iters_double, integer iters_quad, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから反復回数を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt iters] 総反復回数
\item[\tt iters\_double] 倍精度演算の反復回数
\item[\tt iters\_quad] 4倍精度演算の反復回数
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_get\_time}
\begin{screen}
\verb|C       int lis_solver_get_time(LIS_SOLVER solver, double *times)|\\
\verb|Fortran subroutine lis_solver_get_time(LIS_SOLVER solver, real*8 times,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから計算時間を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt times] 経過時間
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_get\_timeex}
\begin{screen}
\verb|C       int lis_solver_get_timeex(LIS_SOLVER solver, double *times,|\\
\verb|         double *itimes, double *ptimes, double *p_c_times, double *p_i_times)|\\
\verb|Fortran subroutine lis_solver_get_timeex(LIS_SOLVER solver, real*8 times,|\\
\verb|         real*8 itimes, real*8 ptimes, real*8 p_c_times, real*8 p_i_times,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから計算時間を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt times] itimesとptimesの合計
\item[\tt itimes] 線型方程式系解法の経過時間
\item[\tt ptimes] 前処理の経過時間
\item[\tt p\_c\_times] 前処理行列作成の経過時間
\item[\tt p\_i\_times] 線型方程式系解法中の前処理の経過時間
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_get\_residualnorm}
\begin{screen}
\verb|C       int lis_solver_get_residualnorm(LIS_SOLVER solver, LIS_REAL *residual)|\\
\verb|Fortran subroutine lis_solver_get_residualnorm(LIS_SOLVER solver,|\\
\verb|         LIS_REAL residual, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから解$x$で再計算した相対残差ノルム$||b - Ax||_2 / ||b||_2$を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt residual]  $b-Ax$ の2ノルム
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_solver\_get\_rhistory}
\begin{screen}
\verb|C       int lis_solver_get_rhistory(LIS_SOLVER solver, LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_solver_get_rhistory(LIS_SOLVER solver,|\\
\verb|         LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから収束履歴を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] 収束履歴が収められたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ベクトル$v$はあらかじめ\verb|lis_vector_create|関数で作成しておかなければならない. 
ベクトル $v$ の次数 $n$ が収束履歴の長さよりも小さい場合は
収束履歴の最初から $n$ 個までを取得する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_solver\_get\_solver}
\begin{screen}
\verb|C       int lis_solver_get_solver(LIS_SOLVER solver, int *nsol)|\\
\verb|Fortran subroutine lis_solver_get_solver(LIS_SOLVER solver, integer nsol,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから選択されている線型方程式系解法の番号を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt solver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nsol] 線型方程式系解法の番号
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
線型方程式系解法の番号は以下の通りである. \\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{l|l||l|l}\hline\hline
 解法        & 番号 & 解法         & 番号 \\ \hline
 CG          & 1    & SOR          & 12    \\
 BiCG        & 2    & BiCGSafe     & 13    \\
 CGS         & 3    & CR           & 14    \\
 BiCGSTAB    & 4    & BiCR         & 15    \\
 BiCGSTAB(l) & 5    & CRS          & 16    \\
 GPBiCG      & 6    & BiCRSTAB     & 17    \\
 TFQMR       & 7    & GPBiCR       & 18    \\
 Orthomin(m) & 8    & BiCRSafe     & 19    \\
 GMRES(m)    & 9    & FGMRES(m)    & 20    \\
 Jacobi      & 10   & IDR(s)       & 21    \\
Gauss-Seidel & 11   & MINRES       & 22    \\ 
\hline         
\end{tabular}
\end{center}
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_get\_solvername}
\begin{screen}
\verb|C       int lis_get_solvername(int nsol, char *name)|\\
\verb|Fortran subroutine lis_get_solvername(integer nsol, character name, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
線型方程式系解法の番号から解法名を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nsol] 線型方程式系解法の番号
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt name] 線型方程式系解法名
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{固有値問題の求解}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_create}
\begin{screen}
\verb|C       int lis_esolver_create(LIS_ESOLVER *esolver)|\\
\verb|Fortran subroutine lis_esolver_create(LIS_ESOLVER esolver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバ (固有値解法の情報を格納する構造体) を作成する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ソルバは固有値解法の情報を持つ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_destroy}
\begin{screen}
\verb|C       int lis_esolver_destroy(LIS_ESOLVER esolver)|\\
\verb|Fortran subroutine lis_esolver_destroy(LIS_ESOLVER esolver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
不要になったソルバをメモリから破棄する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] メモリから破棄するソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_set\_option}
  \label{sec:setoptions}
\begin{screen}
\verb|C       int lis_esolver_set_option(char *text, LIS_ESOLVER esolver)|
\verb|Fortran subroutine lis_esolver_set_option(character text, LIS_ESOLVER esolver,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
固有値解法のオプションをソルバに設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt text] コマンドラインオプション
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
以下に指定可能なコマンドラインオプションを示す. \verb=-e {pi|1}=は\verb=-e pi=または\verb=-e 1=
を意味する. \\
\verb=-emaxiter [1000]=は\verb=-emaxiter=のデフォルト値が$1000$であることを意味する. 
\\
\\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 固有値解法の指定} デフォルト: \verb=-e pi= \\
\begin{tabular}{l|lll}\hline\hline
 固有値解法               & オプション              &  補助オプション    & \\ \hline
 Power Iteration                   & \verb=-e {pi|1}=        &    \\ 
 Inverse Iteration                 & \verb=-e {ii|2}=        &    \verb=-i [bicg]= & 線型方程式系解法 \\
 Approximate Inverse Iteration     & \verb=-e {aii|3}=       &    \\
 Rayleigh Quotient Iteration       & \verb=-e {rqi|4}=       &    \verb=-i [bicg]= & 線型方程式系解法 \\
 Subspace Iteration                & \verb=-e {si|5}=        &    \verb=-ss [2]= & 部分空間の大きさ \\
                                   &                         &    \verb=-m [0]= & モード番号 \\
 Lanczos Iteration                 & \verb=-e {li|6}=        &    \verb=-ss [2]= & 部分空間の大きさ \\
                                   &                         &    \verb=-m [0]= & モード番号 \\
 Conjugate Gradient                & \verb=-e {cg|7}=        &    \\
 Conjugate Residual                & \verb=-e {cr|8}=        &    \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 前処理の指定} デフォルト: \verb=-p ilu=\\
\begin{tabular}{l|lll}\hline\hline
前処理   & オプション           & 補助オプション \\ \hline
なし     & \verb=-p {none|0}=    &   \\
Jacobi   & \verb=-p {jacobi|1}=  &     \\
ILU(k)   & \verb=-p {ilu|2}=     & \verb=-ilu_fill [0]=    & フィルインレベル$k$ \\
SSOR     & \verb=-p {ssor|3}=    & \verb=-ssor_w [1.0]=    & 緩和係数$\omega$ ($0<\omega<2$) \\
Hybrid   & \verb=-p {hybrid|4}=  & \verb=-hybrid_i [sor]=  & 線型方程式系解法 \\
         &                       & \verb=-hybrid_maxiter [25]= & 最大反復回数 \\
         &                       & \verb=-hybrid_tol [1.0e-3]= & 収束判定基準 \\
         &                       & \verb=-hybrid_w [1.5]=      & SORの緩和係数$\omega$ ($0<\omega<2$) \\
         &                       & \verb=-hybrid_ell [2]=      & BiCGSTAB(l)の次数$l$\\
         &                       & \verb=-hybrid_restart [40]= & GMRES(m), Orthomin(m)の \\
         &                       &                             & リスタート値$m$ \\
I+S      & \verb=-p {is|5}=      & \verb=-is_alpha [1.0]=  & $I+\alpha S^{(m)}$型前処理のパラメータ$\alpha$ \\
         &                       & \verb=-is_m [3]=        & $I+\alpha S^{(m)}$型前処理のパラメータ$m$ \\
SAINV    & \verb=-p {sainv|6}=   & \verb=-sainv_drop [0.05]=    & ドロップ基準\\
SA-AMG   & \verb=-p {saamg|7}=   & \verb=-saamg_unsym [false]=     & 非対称版の選択 \\
         &                       &                                 & (行列構造は対称とする) \\
         &                       & \verb=-saamg_theta [0.05|0.12]= & ドロップ基準 $a^2_{ij}\le\theta^2|a_{ii}||a_{jj}|$ \\
         &                       &                             & (対称\verb=|=非対称) \\
Crout ILU& \verb=-p {iluc|8}=    & \verb=-iluc_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-iluc_rate [5.0]=     & 最大フィルイン数の倍率 \\
ILUT     & \verb=-p {ilut|9}=    & \verb=-ilut_drop [0.05]=    & ドロップ基準    \\
         &                       & \verb=-ilut_rate [5.0]=     & 最大フィルイン数の倍率 \\
Additive Schwarz  & \verb=-adds true=   &  \verb=-adds_iter [1]= & 繰り返し回数   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf その他のオプション}\\
\begin{tabular}{l|ll}\hline\hline
オプション &                          \\ \hline
\verb=-emaxiter [1000]= & 最大反復回数         \\ 
\verb=-etol [1.0e-12]=  & 収束判定基準              \\
\verb=-eprint [0]=      & 残差の画面表示                 \\
                       & \verb=-eprint {none|0}     =  何もしない \\
                       & \verb=-eprint {mem|1}      =  収束履歴をメモリに保存する\\
                       & \verb=-eprint {out|2}      =  収束履歴を画面に表示する\\
                       & \verb=-eprint {all|3}      =  収束履歴をメモリに保存し画面に表示する\\
\verb=-ie [ii]= & Lanczos Iteration, Subspace Iteration の内部で使用する固有値解法の指定  \\
                       & \verb=-ie {pi|1}     =  Power Iteration (Subspace Iteration のみ) \\
                       & \verb=-ie {ii|2}     =  Inverse Iteration \\
                       & \verb=-ie {aii|3}    =  Approximate Inverse Iteration \\
                       & \verb=-ie {rqi|4}    =  Rayleigh Quotient Iteration \\
\verb=-shift [0.0]= & 固有値のシフト量  \\
\verb=-initx_ones [true]= & 初期ベクトル$x_{0}$の振舞い  \\
                       & \verb=-initx_ones {false|0}     =  与えられた値を使用 \\
                       & \verb=-initx_ones {true|1}      =  すべての要素を$1$にする\\
\verb=-omp_num_threads [t]= & 実行スレッド数         \\ 
                            & \verb=t=は最大スレッド数 \\
\verb=-estorage [0]=   & 行列格納形式 \\
\verb=-estorage_block [2]= & BSR, BSCのブロックサイズ \\ 
\hline         
\end{tabular}
\end{center}
\end{minipage}
\\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
{\bf 演算精度} デフォルト: \verb=-ef double=\\
\begin{tabular}{l|lll}\hline\hline
精度     & オプション           & 補助オプション \\ \hline
倍精度   & \verb=-ef {double|0}=    &   \\
4倍精度  & \verb=-ef {quad|1}=    &   \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_set\_optionC}
\begin{screen}
\verb|C       int lis_esolver_set_optionC(LIS_ESOLVER esolver)|\\
\verb|Fortran subroutine lis_esolver_set_optionC(LIS_ESOLVER esolver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ユーザプログラム実行時にコマンドラインで指定された固有値解法のオプションをソルバに設定する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolve}
\begin{screen}
\verb|C       int lis_esolve(LIS_MATRIX A, LIS_VECTOR x,|\\
\verb|         LIS_REAL evalue, LIS_ESOLVER esolver)|\\
\verb|Fortran subroutine lis_esolve(LIS_MATRIX A, LIS_VECTOR x,|\\
\verb|         LIS_ESOLVER esolver, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
指定された解法で固有値問題$Ax=\lambda x$を解く. 
ソルバに与えられた出力は
\verb|lis_esolver_get_iters|, \verb|lis_esolver_get_time|, 
\verb|lis_esolver_get_evalues|, \verb|lis_esolver_get_evectors|, \\
\verb|lis_esolver_get_residualnorm|に格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 係数行列
\item[\tt x] 初期ベクトル
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt evalue] \verb|-m[0]| オプションで指定されたモードの固有値
\item[\tt x] 固有値に対応する固有ベクトル
\item[\tt esolver] 反復回数, 計算時間等の情報
\item[\tt ierr] リターンコード (0)
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_get\_status}
\begin{screen}
\verb|C       int lis_esolver_get_status(LIS_ESOLVER esolver, int *status)|\\
\verb|Fortran subroutine lis_esolver_get_status(LIS_ESOLVER esolver, integer status,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから状態を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt status] 状態
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_get\_iters}
\begin{screen}
\verb|C       int lis_esolver_get_iters(LIS_ESOLVER esolver, int *iters)|\\
\verb|Fortran subroutine lis_esolver_get_iters(LIS_ESOLVER esolver, integer iters,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから反復回数を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt iters] 反復回数
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_get\_itersex}
\begin{screen}
\verb|C       int lis_esolver_get_itersex(LIS_ESOLVER esolver, int *iters)|\\
\verb|Fortran subroutine lis_esolver_get_itersex(LIS_ESOLVER esolver, integer iters,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから反復回数を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt iters] 総反復回数
\item[\tt iters\_double] 倍精度演算の反復回数
\item[\tt iters\_quad] 4倍精度演算の反復回数
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_get\_time}
\begin{screen}
\verb|C       int lis_esolver_get_time(LIS_ESOLVER esolver, double *times)|\\
\verb|Fortran subroutine lis_esolver_get_time(LIS_ESOLVER esolver, real*8 times,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから計算時間を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt times] 経過時間
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_get\_timeex}
\begin{screen}
\verb|C       int lis_esolver_get_timeex(LIS_ESOLVER esolver, double *times,|\\
\verb|         double *itimes, double *ptimes, double *p_c_times, double *p_i_times)|\\
\verb|Fortran subroutine lis_esolver_get_timeex(LIS_ESOLVER esolver, real*8 times,|\\
\verb|         real*8 itimes, real*8 ptimes, real*8 p_c_times, real*8 p_i_times,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから計算時間を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt times] 固有値解法の経過時間
\item[\tt itimes] 固有値解法中の線型方程式系解法の経過時間
\item[\tt ptimes] 固有値解法中の線型方程式系解法前処理の経過時間
\item[\tt p\_c\_times] 前処理行列作成の経過時間
\item[\tt p\_i\_times] 線型方程式系解法中の前処理の経過時間
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_get\_residualnorm}
\begin{screen}
\verb|C       int lis_esolver_get_residualnorm(LIS_ESOLVER esolver, LIS_REAL *residual)|\\
\verb|Fortran subroutine lis_esolver_get_residualnorm(LIS_ESOLVER esolver,|\\
\verb|         LIS_REAL residual, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから固有ベクトル$x$で再計算した相対残差ノルム $||\lambda x-Ax||_2/\lambda$ を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt residual]  $(\lambda x-Ax)/\lambda$ の2ノルム
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_get\_rhistory}
\begin{screen}
\verb|C       int lis_esolver_get_rhistory(LIS_ESOLVER esolver, LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_esolver_get_rhistory(LIS_ESOLVER esolver,|\\
\verb|         LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
収束履歴をベクトルに格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] 収束履歴が収められたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ベクトル$v$はあらかじめ\verb|lis_vector_create|関数で作成しておかなければならない. 
ベクトル $v$ の次数 $n$ が収束履歴の長さよりも小さい場合は
収束履歴の最初から $n$ 個までを取得する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_get\_evalues}
\begin{screen}
\verb|C       int lis_esolver_get_evalues(LIS_ESOLVER esolver, LIS_VECTOR v)|\\
\verb|Fortran subroutine lis_esolver_get_evalues(LIS_ESOLVER esolver,|\\
\verb|         LIS_VECTOR v, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバからすべての固有値を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v]  固有値が納められたベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ベクトル$v$はあらかじめ\verb|lis_vector_create|関数で作成しておかなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_esolver\_get\_evectors}
\begin{screen}
\verb|C       int lis_esolver_get_evectors(LIS_ESOLVER esolver, LIS_MATRIX A)|\\
\verb|Fortran subroutine lis_esolver_get_evectors(LIS_ESOLVER esolver,|\\
\verb|         LIS_MATRIX A, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバからすべての固有ベクトルを取得し, 行列$A$にCRS形式で格納する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A]  固有ベクトルが納められた行列
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
行列$A$はあらかじめ\verb|lis_matrix_create|関数で作成しておかなければならない. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_esolver\_get\_esolver}
\begin{screen}
\verb|C       int lis_esolver_get_esolver(LIS_ESOLVER esolver, int *nsol)|\\
\verb|Fortran subroutine lis_esolver_get_esolver(LIS_ESOLVER esolver, integer nsol,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ソルバから選択されている固有値解法の番号を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt esolver] ソルバ
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nsol] 固有値解法の番号
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
固有値解法の番号は以下の通りである. \\ \\
\begin{minipage}[t]{\textwidth}
\begin{center}
\begin{tabular}{l|l}\hline\hline
 解法        & 番号 \\ \hline

 Power Iteration                              & 1    \\ 
 Inverse Iteration                            & 2    \\
 Approximate Inverse Iteration                & 3    \\
 Rayleigh Quotient Iteration                  & 4    \\
 Subspace Iteration                           & 5    \\
 Lanczos Iteration                            & 6    \\
 Conjugate Gradient                           & 7    \\
 Conjugate Residual                           & 8    \\
\hline         
\end{tabular}
\end{center}
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_get\_esolvername}
\begin{screen}
\verb|C       int lis_get_esolvername(int esolver, char *name)|\\
\verb|Fortran subroutine lis_get_esolvername(integer esolver, character name,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
固有値解法の番号から解法名を取得する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt nesol] 固有値解法の番号
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt name] 固有値解法名
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{ファイル入出力}
  \subsubsection{lis\_input}
\begin{screen}
\verb|C       int lis_input(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x, char *filename)|\\
\verb|Fortran subroutine lis_input(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
\verb|         character filename, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ファイルから行列, ベクトルデータを読み込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt filename] 読み込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 指定された格納形式の行列
\item[\tt b] 右辺ベクトル
\item[\tt x] 解ベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
対応しているファイル形式は以下のとおりである. 
\begin{itemize}
\item Matrix Market形式 (ベクトルデータを読み込めるよう拡張) 
\item Harwell-Boeing形式
\end{itemize}
これらのデータ構造は付録\ref{sec:matinp}を参照せよ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_input\_vector}
\begin{screen}
\verb|C       int lis_input_vector(LIS_VECTOR v, char *filename)|\\
\verb|Fortran subroutine lis_input_vector(LIS_VECTOR v, character filename, integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
ファイルからベクトルデータを読み込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt filename] 読み込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] ベクトル
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
対応しているファイル形式は
\begin{itemize}
\item PLAIN形式
\item MM形式
\end{itemize}
これらのデータ構造は付録\ref{sec:matinp}を参照せよ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_input\_matrix}
\begin{screen}
\verb|C       int lis_input_matrix(LIS_MATRIX A, char *filename)|\\
\verb|Fortran subroutine lis_input_matrix(LIS_MATRIX A, character filename,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
ファイルから行列データを読み込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt filename] 読み込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 指定された格納形式の行列
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
対応しているファイル形式は以下のとおりである. 
\begin{itemize}
\item Matrix Market形式
\item Harwell-Boeing形式
\end{itemize}
これらのデータ構造は付録\ref{sec:matinp}を参照せよ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_output}
\begin{screen}
\verb|C       int lis_output(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x, int format,|\\
\verb|         char *filename)|\\
\verb|Fortran subroutine lis_output(LIS_MATRIX A, LIS_VECTOR b, LIS_VECTOR x,|\\
\verb|         integer format, character filename, integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列, ベクトルデータをファイルに書き込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt b] 右辺ベクトル. ファイルに書き込まないときは{\tt NULL}
\item[\tt x] 解ベクトル. ファイルに書き込まないときは{\tt NULL}
\item[\tt format] ファイル形式
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_FMT\_MM] Matrix Market形式
%\item[\tt LIS\_FMT\_MMB] Matrix Market形式(BINARY)
\end{namelist}
\item[\tt filename] 書き込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ファイル形式のデータ構造は付録\ref{sec:matinp}を参照せよ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_output\_vector}
\begin{screen}
\verb|C       int lis_output_vector(LIS_VECTOR v, int format, char *filename)|
\verb|Fortran subroutine lis_output_vector(LIS_VECTOR v, integer format,|\\
\verb|         character filename, integer ierr) |
\end{screen}
{\bf 機能}\\
\indent
ベクトルデータをファイルに書き込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt v] ベクトル
\item[\tt format] ファイル形式
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_FMT\_PLAIN] PLAIN形式
\item[\tt LIS\_FMT\_MM] MM形式
\end{namelist}
\item[\tt filename] 書き込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
{\bf 注釈}\\
\indent
ファイル形式のデータ構造は付録\ref{sec:matinp}を参照せよ. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_output\_matrix}
\begin{screen}
\verb|C       int lis_output(LIS_MATRIX A, int format, char *filename)|\\
\verb|Fortran subroutine lis_output(LIS_MATRIX A, integer format, character filename,|\\
\verb|         integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
行列データをファイルに書き込む. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt A] 行列
\item[\tt format] ファイル形式
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt LIS\_FMT\_MM] Matrix Market形式
%\item[\tt LIS\_FMT\_MMB] Matrix Market形式(BINARY)
\end{namelist}
\item[\tt filename] 書き込むファイルのファイル名
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{その他}
  \subsubsection{lis\_initialize}
\begin{screen}
\verb|C       int lis_initialize(int* argc, char** argv[])|\\
\verb|Fortran subroutine lis_initialize(integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
MPIの初期化, コマンドライン引数の取得等の初期化処理を行う. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt argc] コマンドライン引数の数
\item[\tt argv] コマンドライン引数
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{lis\_finalize}
\begin{screen}
\verb|C       void lis_finalize()|\\
\verb|Fortran subroutine lis_finalize(integer ierr)|
\end{screen}
{\bf 機能}\\
\indent
終了処理を行う. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし] 
\end{namelist}
{\bf 出力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt ierr] リターンコード
\end{namelist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
  \subsubsection{lis\_wtime}
\begin{screen}
\verb|C       double lis_wtime()|\\
\verb|Fortran function lis_wtime()|
\end{screen}
{\bf 機能}\\
\indent
経過時間を計測する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし]
\end{namelist}
{\bf 出力}\\
\indent
ある時点からの時間経過をdouble型の値 (単位は秒) として返す. 
\\ \\
\noindent
{\bf 注釈}\\
\indent
処理時間を測定したい場合は, 
時間の測定を開始する直前と終了した直後の時間を\verb|lis_wtime|により測定し, 
その差を求める. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsubsection{CHKERR}
\begin{screen}
\verb|C       void CHKERR(int err)|\\
\verb|Fortran subroutine CHKERR(integer err)|
\end{screen}
{\bf 機能}\\
\indent
実行した関数がエラーかどうかを判断する. 
\\ \\
\noindent
{\bf 入力}
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt err] リターンコード
\end{namelist}
{\bf 出力}\\
\begin{namelist}{XXXXXXXXXXXXXXXXXXXX}
\item[\tt なし] 
\end{namelist}
\noindent
{\bf 注釈}\\
\indent
エラーならば\verb|lis_finalize|を実行した後プログラムを強制終了する. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\addcontentsline{toc}{section}{参考文献}
\begin{thebibliography}{10}

\bibitem{fujino01}
藤野清次, 藤原牧, 吉田正浩.
\newblock 準残差の最小化に基づく積型BiCG 法.
\newblock 日本計算工学会論文集, 2005. 
http://save.k.u-tokyo.ac.jp/jsces/trans/trans2005/No20050028.pdf.

\bibitem{sogabe01}
曽我部知広, 杉原正顕, 張紹良.
\newblock 共役残差法の非対称行列への拡張.
\newblock 日本応用数理学会論文誌,  Vol.~15, No.~3, pp.\ 445--460, 2005

\bibitem{abe02}
阿部邦美, 曽我部知広, 藤野清次, 張紹良.
\newblock 非対称行列用共役残差法に基づく積型反復解法.
\newblock 情報処理学会論文誌,  Vol.~48, No.~SIG8(ACS18), pp.\ 11--21, 2007.

\bibitem{fujino02}
藤野清次, 尾上勇介.
\newblock BiCR 法の残差をベースにした BiCRSafe 法の収束性評価.
\newblock 情報処理学会研究報告, 2007-HPC-111, pp.\ 25--30, 2007.

\bibitem{fgmres}
Y. Saad.
\newblock A Flexible Inner-outer Preconditioned GMRES Algorithm.
\newblock SIAM J. Sci. Stat. Comput., Vol.~14, pp.\ 461--469, 1993.

\bibitem{ilut}
Y. Saad.
\newblock {ILUT}: a dual threshold incomplete ${LU}$ factorization.
\newblock Numerical Linear Algebra with Applications, Vol.~1, No.~4, pp.\ 387--402, 1994. 

\bibitem{ITSOL}
ITSOL: ITERATIVE SOLVERS package \\
\newblock http://www-users.cs.umn.edu/\textasciitilde saad/software/ITSOL/index.html

\bibitem{iluc}
N. Li, Y. Saad and E. Chow.
\newblock Crout version of ILU for general sparse matrices.
\newblock SIAM J. Sci. Comput., Vol.~25, pp.\ 716--728, 2003. 

\bibitem{kohno01}
{T. Kohno}, {H. Kotakemori} and {H. Niki}.
\newblock Improving the Modified Gauss-Seidel Method for Z-matrices.
\newblock Linear Algebra and its Applications,  Vol.~267, pp.\ 113--123, 1997.

\bibitem{fujii01}
A. Fujii, A. Nishida, and Y. Oyanagi.
\newblock Evaluation of Parallel Aggregate Creation Orders : Smoothed Aggregation Algebraic Multigrid Method.
\newblock High Performance Computational Science And Engineering, pp.\ 99--122, Springer, 2005. 

\bibitem{abe01}
阿部邦美, 張紹良, 長谷川秀彦, 姫野龍太郎.
\newblock SOR  法を用いた可変的前処理付き一般化共役残差法.
\newblock 日本応用数理学会論文誌,  Vol.~11, No.~4, pp.\ 157--170, 2001.

\bibitem{bridson01}
R. Bridson and W.-P. Tang.
\newblock Refining an approximate inverse.
\newblock J. Comput. Appl. Math., Vol.~123, pp.\ 293--306, 2000. 

\bibitem{idrs}
P. Sonnerveld and M. B. van Gijzen.
\newblock IDR(s): a family of simple and fast algorithms for solving large nonsymmetric systems of linear equations.
\newblock SIAM J. Sci. Comput., Vol.~31, Issue~2, pp.\ 1035--1062, 2008.

\bibitem{greenbaum}
A. Greenbaum.
\newblock Iterative Methods for Solving Linear Systems.
\newblock SIAM, 1997.

\bibitem{knyazev}
A. V. Knyazev.
\newblock Toward the Optimal Preconditioned Eigensolver: Locally Optimal
	Block Preconditioned Conjugate Gradient Method.
\newblock SIAM J. Sci. Comput., Vol.~23, No.~2, pp.\ 517-541, 2001. 

\bibitem{nishida1}
A. Nishida.
\newblock Experience in Developing an Open Source Scalable Software
	Infrastructure in Japan.
\newblock Lecture Notes in Computer Science 6017, Springer, pp.\ 87-98, 2010.

\bibitem{suetomi}
E. Suetomi and H. Sekimoto.
\newblock Conjugate gradient like methods and their application to
	eigenvalue problems for neutron diffusion equation.
\newblock Annals of Nuclear Energy, Vol.~18, No.~4, pp.\ 205-227, 1991.

\bibitem{dd}
D. H. Bailey.
\newblock A fortran-90 double-double library.
\newblock http://www.nersc.gov/\~{}dhbailey/mpdist /mpdist.html.

\bibitem{qd}
Y. Hida, X. S. Li and D. H. Bailey.
\newblock Algorithms for quad-double precision floating point arithmetic.
\newblock Proceedings of the 15th Symposium on Computer Arithmetic, pp.\
	155--162, 2001.

\bibitem{dekker}
T. Dekker.
\newblock A floating-point technique for extending the available precision.
\newblock Numerische Mathematik, vol.18 pp.\ 224--242, 1971.

\bibitem{Knuth}
D.~E. Knuth. 
The Art of Computer Programming: Seminumerical Algorithms, vol.2.
Addison-Wesley, 1969.

\bibitem{Bailey:High-Precision}
D.~H. Bailey.
\newblock High-Precision Floating-Point Arithmetic in Scientific Computation.
\newblock Computing in Science and Engineering, Volume 7, Issue 3, pp.\ 54--61, IEEE, 2005.

\bibitem{intel}
\newblock Intel Fortran Compiler User's Guide Vol I.

\bibitem{quadlis}
小武守恒, 藤井昭宏, 長谷川秀彦, 西田晃. 
\newblock 反復法ライブラリ向け4倍精度演算の実装とSSE2を用いた高速化.
\newblock 情報処理学会論文誌「コンピューティングシステム」, Vol.~1, No.~1, pp.\ 73--84, 2008.

\bibitem{Bar00}
R. Barrett, et al.
\newblock Templates for the Solution of Linear Systems: Building Blocks for Iterative Methods.
\newblock SIAM, 1994.

\bibitem{bai00}
Z. Bai, et al.
\newblock Templates for the Solution of Algebraic Eigenvalue Problems. 
\newblock SIAM, 2000.

\bibitem{Saad90}
Y. Saad.
\newblock {SPARSKIT: a basic tool kit for sparse matrix computations,
  version 2}, June 1994.
\newblock http://www.cs.umn.edu/\textasciitilde saad/software/SPARSKIT/sparskit.html.


\bibitem{PETSc}
S. Balay, et al.
\newblock {PETSc} users manual.
\newblock Technical Report ANL-95/11, Argonne National Laboratory, August 2004.

\bibitem{Aztec}
R.~S. Tuminaro, et al.
\newblock Official {Aztec} user's guide, version 2.1.
\newblock Technical Report SAND99-8801J, Sandia National Laboratories, November
  1999.

\bibitem{ARPACK}
R. B. Lehoucq, D. C. Sorensen, and C. Yang.
\newblock ARPACK Users' Guide: Solution of Large-scale Eigenvalue Problems with implicitly-restarted Arnoldi Methods. 
\newblock SIAM, 1998. 

\bibitem{bramley95splib}
R. Bramley and X. Wang.
\newblock SPLIB: A library of iterative methods for sparse linear system.
\newblock Technical report, Indiana University--Bloomington, 1995.

\bibitem{matrixmarket}
Matrix Market.
\newblock http://math.nist.gov/MatrixMarket.

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\appendix
\section{ファイル形式}
\label{sec:matinp}
本節では, 本ライブラリで利用できるファイル形式について述べる. 
\subsection{拡張Matrix Market形式}
Matrix Market形式\cite{matrixmarket}は, ベクトルデータを
格納できない. 本ライブラリはベクトルを格納できるように拡張している. 
$M \times N$の行列$A=(a_{ij})$の非零要素数を$L$とする. 
$a_{ij} = A(I,J)$とする. ファイル形式を以下に示す.

{\small
\begin{verbatim}
%%MatrixMarket matrix coordinate real general  <-- ヘッダ
%                                              <-+ 
%                                                | 0行以上のコメント行
%                                              <-+
M N L B X                                      <-- 行数 列数 非零数 (0 or 1) (0 or 1)
I1 J1 A(I1,J1)                                 <-+
I2 J2 A(I2,J2)                                   | 行番号 列番号 値
 . . .                                           | インデックスは1-base
IL JL A(IL,JL)                                 <-+
I1 B(I1)                                       <-+
I2 B(I2)                                         | B=1の場合のみ存在する
 . . .                                           | 行番号 値
IM B(IM)                                       <-+
I1 X(I1)                                       <-+
I2 X(I2)                                         | X=1の場合のみ存在する
 . . .                                           | 行番号 値
IM X(IM)                                       <-+
\end{verbatim}
}

(\ref{eq:matavecv})式の行列$A$とベクトル$b$に対するファイル形式を以下に示す. 
\begin{equation}
A = 
\left(
\begin{array}{cccc}
2 & 1 &   &    \\
1 & 2 & 1 &    \\ 
  & 1 & 2 & 1 \\
  &   & 1 & 2 
\end{array}
\right)
~~~~~~~~~~~~
b = 
\left(
\begin{array}{c}
0 \\
1 \\ 
2 \\
3  
\end{array}
\right)
\label{eq:matavecv}
\end{equation}

{\small
\begin{verbatim}
%%MatrixMarket matrix coordinate real general
4 4 10 1 0
1 2  1.00e+00
1 1  2.00e+00
2 3  1.00e+00
2 1  1.00e+00
2 2  2.00e+00
3 4  1.00e+00
3 2  1.00e+00
3 3  2.00e+00
4 4  2.00e+00
4 3  1.00e+00
1  0.00e+00
2  1.00e+00
3  2.00e+00
4  3.00e+00
\end{verbatim}
}

\subsection{Harwell-Boeing形式}
Harwell-Boeing形式はCCS形式で行列を格納する. 
{\tt value}を行列$A$の非零要素の値, {\tt index}を非零要素の行番号, 
{\tt ptr}を{\tt value}と{\tt index}の各列の開始位置を格納する
配列とする. ファイル形式を以下に示す.

{\small
\begin{verbatim}
1行目 (A72,A8)
   1 - 72 Title
  73 - 80 Key
2行目 (5I14)
   1 - 14 ヘッダを除く総行数
  15 - 28 ptrの行数
  29 - 42 indexの行数
  43 - 56 valueの行数
  57 - 70 右辺の行数
3行目 (A3,11X,4I14)
   1 -  3 行列の種類
            1列目: R Real matrix
                   C Complex matrix (非対応)
                   P Pattern only (非対応)
            2列目: S Symmetric
                   U Unsymmetric
                   H Hermitian (非対応)
                   Z Skew symmetric (非対応)
                   R Rectangular (非対応)
            3列目: A Assembled
                   E Elemental matrices (非対応)
   4 - 14 空白
  15 - 28 行数
  29 - 42 列数
  43 - 56 非零要素数
  57 - 70 0
4行目 (2A16,2A20)
   1 - 16 ptrの形式
  17 - 32 indexの形式
  33 - 52 valueの形式
  53 - 72 右辺の形式
5行目 (A3,11X,2I14) 右辺が存在する場合
   1      右辺の種類
            F フルベクトル
            M 行列と同じ形式 (非対応)
   2      初期値が与えられているならば G
   3      解が与えられているならば X
   4 - 14 空白
  15 - 28 右辺の数
  29 - 42 非零要素数
\end{verbatim}
}

(\ref{eq:matavecv})式の行列$A$とベクトル$b$に対するファイル形式を以下に示す.

{\small
\begin{verbatim}
1--------10--------20--------30--------40--------50--------60--------70--------80
Harwell-Boeing format sample                                            Lis
             8             1             1             4             2
RUA                        4             4            10             4
(11i7)          (13i6)          (3e26.18)           (3e26.18)
F                          1             0
      1      3      6      9
     1     2     1     2     3     2     3     4     3     4
  2.000000000000000000E+00  1.000000000000000000E+00  1.000000000000000000E+00
  2.000000000000000000E+00  1.000000000000000000E+00  1.000000000000000000E+00
  2.000000000000000000E+00  1.000000000000000000E+00  1.000000000000000000E+00
  2.000000000000000000E+00
  0.000000000000000000E+00  1.000000000000000000E+00  2.000000000000000000E+00
  3.000000000000000000E+00
\end{verbatim}
}

\subsection{ベクトル用拡張Matrix Market形式}
Matrix Market形式\cite{matrixmarket}でベクトルデータを
格納できるように拡張している. 
次数$N$のベクトル$b=(b_{i})$に対して$b_{i} = B(I)$とする. 
ファイル形式を以下に示す.

{\small
\begin{verbatim}
%%MatrixMarket vector coordinate real general  <-- ヘッダ
%                                              <-+ 
%                                                | 0行以上のコメント行
%                                              <-+
N                                              <-- 行数
I1 B(I1)                                       <-+
I2 B(I2)                                         | 行番号 値
 . . .                                           | インデックスは1-base
IN B(IN)                                       <-+ 
\end{verbatim}
}

(\ref{eq:matavecv})式のベクトル$b$に対するファイル形式を以下に示す.

{\small
\begin{verbatim}
%%MatrixMarket vector coordinate real general
4
1  0.00e+00
2  1.00e+00
3  2.00e+00
4  3.00e+00
\end{verbatim}
}

\subsection{ベクトル用PLAIN形式}
ベクトル用PLAIN形式は
ベクトルの値を始めから順番に書き出したものである. 
次数$N$のベクトル$b=(b_{i})$に対して$b_{i} = B(I)$とする. 
ファイル形式を以下に示す.

{\small
\begin{verbatim}
B(1)                                       <-+
B(2)                                         | 必ずN個
. . .                                        | 
B(N)                                       <-+ 
\end{verbatim}
}

(\ref{eq:matavecv})式のベクトル$b$に対するファイル形式を以下に示す.

{\small
\begin{verbatim}
0.00e+00
1.00e+00
2.00e+00
3.00e+00
\end{verbatim}
}
\end{document}

